<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU/CPU Stress Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #4a6cf7;
            --primary-dark: #3a5bd9;
            --secondary: #6c757d;
            --danger: #dc3545;
            --success: #28a745;
            --warning: #ffc107;
            --dark: #343a40;
            --light: #f8f9fa;
            --background: #f8f9fa;
            --card-bg: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background);
            color: var(--dark);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .header p {
            font-size: 1.2rem;
            color: var(--secondary);
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 25px;
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.15);
        }

        .card-header {
            font-size: 1.5rem;
            font-weight: 500;
            margin-bottom: 20px;
            color: var(--primary);
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }

        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .setting-group select,
        .setting-group input {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            background-color: var(--card-bg);
            color: var(--dark);
        }

        .setting-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
            padding: 0;
            border: none;
        }

        .setting-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        .range-value {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            color: var(--secondary);
            font-size: 0.9rem;
        }

        .btn {
            display: inline-block;
            font-weight: 500;
            color: #fff;
            text-align: center;
            vertical-align: middle;
            cursor: pointer;
            background-color: var(--primary);
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            line-height: 1.5;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }

        .btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-danger {
            background-color: var(--danger);
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-success {
            background-color: var(--success);
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.2);
        }

        .stat-card h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .stat-card .value {
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .canvas-container {
            position: relative;
            height: 300px;
            width: 100%;
            margin: 20px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 30px;
            background-color: var(--card-bg);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .tab {
            padding: 12px 20px;
            background-color: transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .tab:hover {
            background-color: rgba(74, 108, 247, 0.1);
        }

        .tab.active {
            background-color: var(--primary);
            color: white;
            box-shadow: 0 4px 8px rgba(74, 108, 247, 0.3);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: 6px 12px;
            font-size: 0.8rem;
            font-weight: 700;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 50px;
            color: #fff;
            background-color: var(--primary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .badge-success {
            background-color: var(--success);
        }

        .badge-danger {
            background-color: var(--danger);
        }

        .badge-warning {
            background-color: var(--warning);
            color: #212529;
        }

        .progress {
            position: relative;
            height: 12px;
            overflow: hidden;
            background-color: #e9ecef;
            border-radius: 50px;
            margin-bottom: 15px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: transparent;
            font-size: 0.8rem;
            border-radius: 50px;
            position: relative;
            overflow: hidden;
        }

        .progress-text {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--dark);
            font-weight: 500;
            font-size: 0.75rem;
            z-index: 2;
            pointer-events: none;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        table th, table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        table th {
            background-color: #f5f5f5;
            font-weight: 600;
            color: var(--primary);
        }

        table tr:last-child td {
            border-bottom: none;
        }

        table tr:hover td {
            background-color: rgba(74, 108, 247, 0.05);
        }

        #glCanvas, #cpuCanvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 12px;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 300px;
            overflow: hidden;
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
        }

        .overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
        }

        .dark-mode {
            --background: #1a1a1a;
            --card-bg: #2a2a2a;
            --dark: #f8f9fa;
            --light: #343a40;
            --secondary: #adb5bd;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .console {
            background-color: #1a1a1a;
            color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
        }

        .log {
            margin-bottom: 5px;
            line-height: 1.4;
        }

        .log-info {
            color: #4a6cf7;
        }

        .log-warn {
            color: #ffc107;
        }

        .log-error {
            color: #dc3545;
        }
    </style>
</head>
<body>
<div class="container">
        <div class="header">
            <h1>GPU/CPU Stress Test</h1>
            <p>Test your GPU and CPU performance with customizable settings</p>
        </div>

        <div class="tabs">
            <div class="tab active" data-tab="test">Test</div>
            <div class="tab" data-tab="stats">Statistics</div>
            <div class="tab" data-tab="history">History</div>
            <div class="tab" data-tab="settings">Settings</div>
        </div>

        <div class="tab-content active" id="test-tab">
            <div class="card">
                <div class="card-header">Test Mode Selection</div>
                <div class="radio-group">
                    <div class="radio-item">
                        <input type="radio" id="gpu-mode" name="test-mode" value="gpu" checked>
                        <label for="gpu-mode">GPU</label>
                    </div>
                    <div class="radio-item">
                        <input type="radio" id="cpu-single-mode" name="test-mode" value="cpu-single">
                        <label for="cpu-single-mode">CPU (Single Thread)</label>
                    </div>
                    <div class="radio-item">
                        <input type="radio" id="cpu-multi-mode" name="test-mode" value="cpu-multi">
                        <label for="cpu-multi-mode">CPU (Multi Thread)</label>
                    </div>
                </div>

                <div id="gpu-options">
                    <div class="setting-group">
                        <label for="render-api">Rendering API</label>
                        <select id="render-api">
                            <option value="webgl1">WebGL 1</option>
                            <option value="webgl2">WebGL 2</option>
                            <option value="webgpu">WebGPU (Experimental)</option>
                        </select>
                    </div>
                </div>

                <div id="cpu-options" style="display: none;">
                    <div class="setting-group" id="thread-count-container">
                    <label for="thread-count">Thread Count (Multi-threaded mode)</label>
                    <select id="thread-count">
                        <option value="2">2 Threads</option>
                        <option value="4" selected>4 Threads</option>
                        <option value="8">8 Threads</option>
                        <option value="16">16 Threads</option>
                        <option value="auto">Auto (Based on CPU cores)</option>
                    </select>
                </div>

                </div>
            </div>

            <div class="card">
                <div class="card-header">Stress Test Visualization</div>
                <div class="canvas-wrapper">
                    <canvas id="glCanvas"></canvas>
                    <canvas id="cpuCanvas" style="display: none;"></canvas>
                    <div class="overlay">
                        <span id="fps-label">FPS:</span> <span id="fps">0</span> | 
                        <span id="temp-label">Temperature:</span> <span id="temperature">0°C</span> | 
                        <span id="load-label">Load:</span> <span id="load">0%</span>
                    </div>
                </div>

                <div class="progress">
                    <div class="progress-bar" id="test-progress" style="width: 0%"></div>
                    <div class="progress-text">0%</div>
                </div>

                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <span class="badge" id="status-badge">Ready</span>
                        <span style="margin-left: 10px;">Duration: <span id="duration">00:00</span></span>
                    </div>
                    <div>
                        <span>Hardware: <span id="hardware-info">Detecting...</span></span>
                    </div>
                </div>

                <div class="btn-container">
                    <button class="btn btn-success" id="start-btn">Start Test</button>
                    <button class="btn btn-danger" id="stop-btn" disabled>Stop Test</button>
                    <button class="btn" id="save-btn" disabled>Save Results</button>
                </div>
            </div>

            <div class="card">
                <div class="card-header">Test Settings</div>
                <div class="settings">
                    <div class="setting-group">
                    <label for="complexity">Workload Complexity</label>
                    <input type="range" id="complexity" min="1" max="20" value="10">
                    <div class="range-value">
                        <span>Low</span>
                        <span>Medium</span>
                        <span>High</span>
                    </div>
                </div>
                    <div class="setting-group" id="antialiasing-setting">
    <label for="antialiasing">Antialiasing</label>
    <select id="antialiasing">
        <option value="none">None</option>
        <option value="msaa2x">MSAA 2x</option>
        <option value="msaa4x">MSAA 4x</option>
        <option value="msaa8x">MSAA 8x</option>
        <option value="msaa16x">MSAA 16x</option>
    </select>
</div>
                <div class="setting-group">
                    <label for="disable-cache">Disable Browser Caching</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="disable-cache" style="width: auto;">
                        <label for="disable-cache" style="margin: 0;">Enable for more accurate testing</label>
                    </div>
                </div>
                    <div class="setting-group" id="particle-setting">
                    <label for="particleCount">Particle Count (GPU)</label>
                    <input type="range" id="particleCount" min="10000" max="10000000" step="10000" value="1000000">
                    <div class="range-value">
                        <span>10,000</span>
                        <span>5,000,000</span>
                        <span>10,000,000</span>
                    </div>
                </div>
                    <div class="setting-group" id="iteration-setting" style="display: none;">
                        <label for="iterationCount">Iterations (CPU)</label>
                        <input type="range" id="iterationCount" min="10" max="5000" step="10" value="1000">
                        <div class="range-value">
                            <span>10</span>
                            <span>2,500</span>
                            <span>5,000</span>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label for="duration">Test Duration (seconds)</label>
                        <input type="range" id="durationSlider" min="10" max="300" step="10" value="60">
                        <div class="range-value">
                            <span>10s</span>
                            <span>150s</span>
                            <span>300s</span>
                        </div>
                    </div>
                                    <div class="setting-group" id="resolution-setting">
                    <label for="resolution">Render Resolution (GPU)</label>
                    <input type="range" id="resolution" min="0.25" max="4" step="0.25" value="1">
                    <div class="range-value">
                        <span>25%</span>
                        <span>100%</span>
                        <span>400%</span>
                    </div>
                </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">Real-time Performance</div>
                <div class="canvas-container">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>

            <div class="card">
                <div class="card-header">Console Output</div>
                <div class="console" id="console-output">
                    <div class="log log-info">System initialized. Ready to start test.</div>
                </div>
            </div>
        </div>

        <div class="tab-content" id="stats-tab">
            <div class="card">
                <div class="card-header">Current Test Statistics</div>
                <div class="stats-container">
                    <div class="stat-card">
                        <h3>Avg Performance</h3>
                        <div class="value" id="avg-fps">0</div>
                    </div>
                    <div class="stat-card">
                        <h3>Min Performance</h3>
                        <div class="value" id="min-fps">0</div>
                    </div>
                    <div class="stat-card">
                        <h3>Max Performance</h3>
                        <div class="value" id="max-fps">0</div>
                    </div>
                    <div class="stat-card">
                        <h3>Score</h3>
                        <div class="value" id="score">0</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">Performance Analysis</div>
                <div class="canvas-container">
                    <canvas id="distributionChart"></canvas>
                </div>
            </div>
        </div>

        <div class="tab-content" id="history-tab">
            <div class="card">
                <div class="card-header">Historical Performance</div>
                <div class="canvas-container">
                    <canvas id="historyChart"></canvas>
                </div>
                <div class="historical-data">
                    <table>
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Mode</th>
                                <th>Score</th>
                                <th>Avg Performance</th>
                                <th>Duration</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="history-table-body">
                            <tr>
                                <td colspan="6" style="text-align: center;">No data available</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="tab-content" id="settings-tab">
            <div class="card">
                <div class="card-header">Application Settings</div>
                <div class="settings">
                    <div class="setting-group">
                        <label for="theme">Theme</label>
                        <select id="theme">
                            <option value="light">Light</option>
                            <option value="dark">Dark</option>
                            <option value="auto">System Default</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label for="dataRetention">Data Retention (days)</label>
                        <input type="range" id="dataRetention" min="7" max="90" step="7" value="30">
                        <div class="range-value">
                            <span>7 days</span>
                            <span>30 days</span>
                            <span>90 days</span>
                        </div>
                    </div>
                </div>
                <div class="btn-container">
                    <button class="btn" id="clearData">Clear All Data</button>
                    <button class="btn" id="exportData">Export Data</button>
                </div>
            </div>

            <div class="card">
                <div class="card-header">About</div>
                <p>GPU/CPU Stress Test v1.0.0</p>
                <p style="margin-top: 10px;">This tool uses WebGL/WebGPU to test your GPU's performance and JavaScript to test your CPU performance under load.</p>
                <p style="margin-top: 10px;">Note: Results are stored locally in your browser and are not sent to any server.</p>
            </div>
        </div>
    </div>

    <script>
        const consoleOutput = document.getElementById('console-output');
        
        function logToConsole(message, type = 'info') {
            const logElement = document.createElement('div');
            logElement.className = `log log-${type}`;
            logElement.textContent = message;
            consoleOutput.appendChild(logElement);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;

            if (type === 'error') {
                console.error(message);
            } else if (type === 'warn') {
                console.warn(message);
            } else {
                console.log(message);
            }
        }

        const workerCode = `
            self.onmessage = function(e) {
                const { id, iterationCount, complexity } = e.data;
                
                const startTime = performance.now();
                
                // Perform complex calculations
                let result = 0;
                for (let i = 0; i < iterationCount; i++) {
                    // Matrix operations (complexity affects size)
                    const size = 10 * complexity;
                    const matrix = [];
                    
                    // Initialize matrix
                    for (let x = 0; x < size; x++) {
                        matrix[x] = [];
                        for (let y = 0; y < size; y++) {
                            matrix[x][y] = Math.sin(x * y) * Math.cos(x + y);
                        }
                    }
                    
                    // Process matrix
                    for (let x = 0; x < size; x++) {
                        for (let y = 0; y < size; y++) {
                            result += Math.sqrt(Math.pow(matrix[x][y], 2));
                        }
                    }
                }
                
                const duration = performance.now() - startTime;
                
                self.postMessage({
                    id,
                    result,
                    duration
                });
            };
        `;

        function formatNumber(num) {
            return num.toLocaleString('en-US', { maximumFractionDigits: 2 });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function getDateString(date) {
            return date.toISOString().split('T')[0];
        }

        function getCurrentDate() {
            return getDateString(new Date());
        }

        const storageKey = 'stressTest';

        function saveTestResults(results) {
            const storage = localStorage.getItem(storageKey);
            let data = storage ? JSON.parse(storage) : {};
            
            const today = getCurrentDate();
            if (!data[today]) {
                data[today] = [];
            }
            
            results.id = Date.now();
            results.timestamp = new Date().toISOString();
            data[today].push(results);
            
            localStorage.setItem(storageKey, JSON.stringify(data));
            updateHistoryView();
            logToConsole(`Results saved with ID: ${results.id}`, 'info');
        }

        function getAllTestResults() {
            const storage = localStorage.getItem(storageKey);
            return storage ? JSON.parse(storage) : {};
        }

        function clearAllData() {
            if (confirm('Are you sure you want to delete all saved test results? This action cannot be undone.')) {
                localStorage.removeItem(storageKey);
                updateHistoryView();
                logToConsole('All data cleared from local storage', 'info');
            }
        }

        function exportData() {
            const data = getAllTestResults();
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `stress_test_export_${getCurrentDate()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            logToConsole('Data exported successfully', 'info');
        }

        function setupTabs() {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    const tabId = `${tab.getAttribute('data-tab')}-tab`;
                    document.getElementById(tabId).classList.add('active');
                });
            });
        }

        class BaseTest {
            constructor() {
                this.running = false;
                this.startTime = 0;
                this.frames = 0;
                this.fps = 0;
                this.performanceHistory = [];
                this.testDuration = 60;
                this.elapsedTime = 0;
                this.complexity = 5;
                
                this.lastFrameTime = 0;
                this.minPerformance = Infinity;
                this.maxPerformance = 0;
                this.totalPerformance = 0;
                this.performanceReadings = 0;
            }
            
            start() {
                if (this.running) return;
                
                this.running = true;
                this.startTime = performance.now();
                this.frames = 0;
                this.elapsedTime = 0;
                this.performanceHistory = [];
                this.minPerformance = Infinity;
                this.maxPerformance = 0;
                this.totalPerformance = 0;
                this.performanceReadings = 0;

                document.getElementById('status-badge').textContent = 'Running';
                document.getElementById('status-badge').className = 'badge badge-warning';
                document.getElementById('start-btn').disabled = true;
                document.getElementById('stop-btn').disabled = false;
                document.getElementById('save-btn').disabled = true;

                this.testDuration = parseInt(document.getElementById('durationSlider').value);
                this.complexity = parseInt(document.getElementById('complexity').value);
            }
            
            stop() {
                this.running = false;

                let avgPerformance = 0;
                if (this.performanceReadings > 0) {
                    avgPerformance = this.totalPerformance / this.performanceReadings;
                }

                document.getElementById('status-badge').textContent = 'Completed';
                document.getElementById('status-badge').className = 'badge badge-success';
                document.getElementById('start-btn').disabled = false;
                document.getElementById('stop-btn').disabled = true;
                document.getElementById('save-btn').disabled = false;

                document.getElementById('avg-fps').textContent = avgPerformance.toFixed(1);
                document.getElementById('min-fps').textContent = this.minPerformance.toFixed(1);
                document.getElementById('max-fps').textContent = this.maxPerformance.toFixed(1);

                const score = Math.round(avgPerformance * this.complexity);
                document.getElementById('score').textContent = formatNumber(score);

                this.testResults = {
                    date: new Date().toISOString(),
                    score: score,
                    avgPerformance: avgPerformance,
                    minPerformance: this.minPerformance,
                    maxPerformance: this.maxPerformance,
                    duration: this.elapsedTime,
                    complexity: this.complexity,
                    performanceData: this.performanceHistory
                };

                updateDistributionChart(this.performanceHistory);
            }
            
            updateUIStats(currentPerformance) {
                document.getElementById('fps').textContent = Math.round(currentPerformance);
                document.getElementById('duration').textContent = formatTime(this.elapsedTime);
                document.getElementById('test-progress').style.width = `${(this.elapsedTime / this.testDuration) * 100}%`;
                document.getElementById('test-progress').nextElementSibling.textContent = `${Math.round((this.elapsedTime / this.testDuration) * 100)}%`;

                const tempBase = 40 + (10 - currentPerformance / 10) + (this.complexity * 2);
                const tempRandom = Math.random() * 5;
                const temperature = Math.min(95, Math.max(40, tempBase + tempRandom));
                document.getElementById('temperature').textContent = `${Math.round(temperature)}°C`;
                
                const load = Math.min(99, Math.max(50, 70 + (this.complexity * 3) - (currentPerformance / 5)));
                document.getElementById('load').textContent = `${Math.round(load)}%`;
            }
            
            saveResults() {
                if (this.testResults) {
                    saveTestResults(this.testResults);
                }
            }
        }

        class GPUTest extends BaseTest {
            constructor(renderApi = 'webgl1') {
    super();
    this.renderApi = renderApi;
    this.canvas = document.getElementById('glCanvas');
    this.particleCount = 100000;
    this.resolution = 1.0;
    this.antialiasing = 'none';
    this.disableCache = false;
    
    this.gl = null;
    this.initializeContext();
    
    if (!this.gl) {
        logToConsole(`Failed to initialize ${renderApi} context`, 'error');
        return;
    }
    
    this.setupShaders();

                if (this.shaderProgram && this.programInfo) {
        this.setupBuffers();
        this.resize();
        this.detectGPU();
    
        window.addEventListener('resize', () => this.resize());
        
        logToConsole(`GPU test initialized with ${this.renderApi} context`, 'info');
    } else {
        logToConsole(`Failed to initialize shaders for ${this.renderApi}`, 'error');
    }
}
            
           initializeContext() {
    try {
        const antialiasing = document.getElementById('antialiasing').value;
        let antialiasSamples = 0;

        if (antialiasing === 'msaa2x') antialiasSamples = 2;
        else if (antialiasing === 'msaa4x') antialiasSamples = 4;
        else if (antialiasing === 'msaa8x') antialiasSamples = 8;
        
        this.antialiasing = antialiasing;

        const contextOptions = {
            antialias: antialiasSamples > 0,
            depth: true,
            alpha: true,
            powerPreference: 'high-performance'
        };

        if (antialiasSamples > 0) {
            contextOptions.antialiasSamples = antialiasSamples;
        }
        
        switch(this.renderApi) {
            case 'webgl1':
                this.gl = this.canvas.getContext('webgl', contextOptions);
                break;
            case 'webgl2':
                this.gl = this.canvas.getContext('webgl2', contextOptions);
                if (!this.gl) {
                    logToConsole('WebGL 2 not supported, falling back to WebGL 1', 'warn');
                    this.gl = this.canvas.getContext('webgl', contextOptions);
                    this.renderApi = 'webgl1';
                }
                break;
            case 'webgpu':
                logToConsole('WebGPU currently not implemented, using WebGL instead', 'warn');
                this.gl = this.canvas.getContext('webgl2', contextOptions);
                if (this.gl) {
                    this.renderApi = 'webgl2';
                } else {
                    this.gl = this.canvas.getContext('webgl', contextOptions);
                    this.renderApi = 'webgl1';
                }
                break;
        }
        
        if (!this.gl) {
            logToConsole('WebGL is not supported in this browser', 'error');
        } else {
            logToConsole(`Initialized with antialiasing: ${this.antialiasing}`, 'info');

            const antialias = this.gl.getContextAttributes().antialias;
            logToConsole(`Antialiasing enabled: ${antialias ? 'Yes' : 'No'}`, 'info');
        }
    } catch (e) {
        logToConsole(`Error initializing context: ${e.message}`, 'error');
        this.gl = null;
    }
}
            
            detectGPU() {
                if (!this.gl) {
                    document.getElementById('hardware-info').textContent = 'WebGL not supported';
                    return;
                }
                
                const debugInfo = this.gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const renderer = this.gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    document.getElementById('hardware-info').textContent = renderer;
                    logToConsole(`Detected GPU: ${renderer}`, 'info');
                } else {
                    document.getElementById('hardware-info').textContent = 'GPU info not available';
                    logToConsole('Could not detect GPU info - WEBGL_debug_renderer_info extension not available', 'warn');
                }
            }
            
           setupShaders() {
    if (!this.gl) return;
    
    try {
        const vsSource = `
            precision mediump float;
            
            attribute vec4 aVertexPosition;
            attribute vec4 aVertexColor;
            
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform float uTime;
            uniform float uComplexity;
            
            varying vec4 vColor;
            
            void main(void) {
                // Apply time-based transformation
                float offset = sin(uTime * 0.001 * uComplexity) * 0.5;
                vec4 position = aVertexPosition;
                position.x += offset * position.y;
                position.y += cos(uTime * 0.0015 * uComplexity) * 0.3;
                
                gl_Position = uProjectionMatrix * uModelViewMatrix * position;
                gl_PointSize = 2.0;
                vColor = aVertexColor;
            }
        `;

        const fsSource = `
    precision mediump float;
    
    varying vec4 vColor;
    
    uniform float uTime;
    uniform float uComplexity;
    
    void main(void) {
        // Make colors pulsate with time
        float t = abs(sin(uTime * 0.001));
        vec4 color = vColor;
        
        // Create complex iterative calculations that scale with complexity
        for (int i = 0; i < 20; i++) {
            if (float(i) < uComplexity * 2.0) {
                // More expensive calculations with trig functions
                vec3 complex = vec3(
                    sin(color.r * 5.0 * 3.14159 + uTime * 0.0007),
                    cos(color.g * 7.0 * 3.14159 + uTime * 0.0009),
                    tan(color.b * 3.0 * 3.14159 + uTime * 0.0005)
                );
                
                // Add complexity with more calculations
                complex = normalize(complex) * pow(length(complex), uComplexity * 0.1);
                
                // Mix with original color
                color.rgb = mix(color.rgb, complex, 0.1);
                
                // Add more expensive operations
                color.r = mix(color.r, sin(color.g * color.b * uTime * 0.0001), 0.05);
                color.g = mix(color.g, cos(color.r * color.b * uTime * 0.0002), 0.05);
                color.b = mix(color.b, sin(color.r * color.g * uTime * 0.0003), 0.05);
            }
        }
        
        gl_FragColor = color;
    }
`;
        const vertexShader = this.loadShader(this.gl.VERTEX_SHADER, vsSource);
        if (!vertexShader) {
            logToConsole('Failed to compile vertex shader', 'error');
            return;
        }
        
        const fragmentShader = this.loadShader(this.gl.FRAGMENT_SHADER, fsSource);
        if (!fragmentShader) {
            logToConsole('Failed to compile fragment shader', 'error');
            return;
        }
        
        this.shaderProgram = this.gl.createProgram();
        this.gl.attachShader(this.shaderProgram, vertexShader);
        this.gl.attachShader(this.shaderProgram, fragmentShader);
        this.gl.linkProgram(this.shaderProgram);
        
        if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
            const info = this.gl.getProgramInfoLog(this.shaderProgram);
            logToConsole(`Unable to initialize the shader program: ${info}`, 'error');
            this.shaderProgram = null;
            return;
        }
        
        this.programInfo = {
            program: this.shaderProgram,
            attribLocations: {
                vertexPosition: this.gl.getAttribLocation(this.shaderProgram, 'aVertexPosition'),
                vertexColor: this.gl.getAttribLocation(this.shaderProgram, 'aVertexColor'),
            },
            uniformLocations: {
                projectionMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uModelViewMatrix'),
                time: this.gl.getUniformLocation(this.shaderProgram, 'uTime'),
                complexity: this.gl.getUniformLocation(this.shaderProgram, 'uComplexity'),
            },
        };
        
        logToConsole('Shader program initialized successfully', 'info');
    } catch (e) {
        logToConsole(`Error initializing shaders: ${e.message}`, 'error');
        this.shaderProgram = null;
        this.programInfo = null;
    }
}
            
            loadShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    const info = this.gl.getShaderInfoLog(shader);
                    logToConsole(`An error occurred compiling the shaders: ${info}`, 'error');
                    this.gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            setupBuffers() {
                if (!this.gl) return;
                
                try {
                    this.regenerateBuffers();
                } catch (e) {
                    logToConsole(`Error setting up buffers: ${e.message}`, 'error');
                }
            }
            
            regenerateBuffers() {
                if (!this.gl) return;
                
                try {
                    const positions = [];
                    const colors = [];
                    
                    for (let i = 0; i < this.particleCount; i++) {
                        positions.push(
                            (Math.random() * 2 - 1),
                            (Math.random() * 2 - 1),
                            (Math.random() * 2 - 1)
                        );

                        colors.push(
                            Math.random(),
                            Math.random(),
                            Math.random(),
                            1.0
                        );
                    }

                    this.positionBuffer = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);

                    this.colorBuffer = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
                    
                    logToConsole(`Generated buffers with ${this.particleCount} particles`, 'info');
                } catch (e) {
                    logToConsole(`Error creating buffers: ${e.message}`, 'error');
                }
            }
            
            resize() {
                if (!this.gl) return;
                
                try {
                    const devicePixelRatio = window.devicePixelRatio || 1;

                    const displayWidth = this.canvas.clientWidth;
                    const displayHeight = this.canvas.clientHeight;

                    const width = Math.floor(displayWidth * devicePixelRatio * this.resolution);
                    const height = Math.floor(displayHeight * devicePixelRatio * this.resolution);

                    if (this.canvas.width !== width || this.canvas.height !== height) {
                        this.canvas.width = width;
                        this.canvas.height = height;
                        this.gl.viewport(0, 0, width, height);
                        logToConsole(`Canvas resized to ${width}x${height} (${this.resolution}x resolution)`, 'info');
                    }
                } catch (e) {
                    logToConsole(`Error resizing canvas: ${e.message}`, 'error');
                }
            }
            
            start() {
                if (!this.gl || !this.shaderProgram || !this.programInfo) {
                    logToConsole('Cannot start test - WebGL context or shader program not initialized', 'error');
                    alert('GPU test initialization failed. Please try a different API or refresh the page.');
                    return;
                }
                this.detectGPU();
                if (this.canvas.requestPointerLock) {
       try {
           this.canvas.requestPointerLock();
        setTimeout(() => {
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }, 100);
        logToConsole('Attempting to disable FPS limiting', 'info');
    } catch (e) {
       }
    }
                
                super.start();

                this.particleCount = parseInt(document.getElementById('particleCount').value);
                this.resolution = parseFloat(document.getElementById('resolution').value);

                this.regenerateBuffers();
                this.resize();

                this.lastFrameTime = performance.now();
                requestAnimationFrame(this.render.bind(this));
                
              this.testResults = {
        mode: 'gpu',
        renderApi: this.renderApi,
        hardware: document.getElementById('hardware-info').textContent,
        antialiasing: this.antialiasing,
        particleCount: this.particleCount,
        resolution: this.resolution
    };
                
                logToConsole(`Starting GPU test with ${this.renderApi}`, 'info');
            }
            
           render(now) {
    if (!this.running || !this.gl || !this.programInfo) return;

               const deltaTime = now - this.lastFrameTime;
    this.lastFrameTime = now;

               const renderPasses = Math.max(1, Math.floor(this.complexity * 2));

               for (let pass = 0; pass < renderPasses; pass++) {
        try {
            if (pass === 0) {
                this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
            }

            const fieldOfView = 45 * Math.PI / 180;
            const aspect = this.gl.canvas.clientWidth / this.gl.canvas.clientHeight || 1;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();
            
            mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

            const modelViewMatrix = mat4.create();
            const passOffset = pass * 0.01;
            mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -6.0]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, now * 0.001 + passOffset, [0, 1, 0]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, now * 0.0005 + passOffset, [1, 0, 0]);

            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
            this.gl.vertexAttribPointer(
                this.programInfo.attribLocations.vertexPosition,
                3, this.gl.FLOAT, false, 0, 0
            );
            this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);

            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
            this.gl.vertexAttribPointer(
                this.programInfo.attribLocations.vertexColor,
                4, this.gl.FLOAT, false, 0, 0
            );
            this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexColor);

            this.gl.useProgram(this.programInfo.program);

            this.gl.uniformMatrix4fv(
                this.programInfo.uniformLocations.projectionMatrix,
                false, projectionMatrix
            );
            this.gl.uniformMatrix4fv(
                this.programInfo.uniformLocations.modelViewMatrix,
                false, modelViewMatrix
            );
            this.gl.uniform1f(
                this.programInfo.uniformLocations.time,
                now + pass * 100
            );
            this.gl.uniform1f(
                this.programInfo.uniformLocations.complexity,
                this.complexity
            );

            this.gl.drawArrays(this.gl.POINTS, 0, this.particleCount);
        } catch (e) {
            logToConsole(`Render error: ${e.message}`, 'error');
            this.stop();
        }
    }

               if (deltaTime > 0) {
        const currentFps = 1000 / deltaTime;
        this.fps = currentFps;

                   this.totalPerformance += currentFps;
        this.performanceReadings++;
        this.minPerformance = Math.min(this.minPerformance, currentFps);
        this.maxPerformance = Math.max(this.maxPerformance, currentFps);

                   const secondsElapsed = (now - this.startTime) / 1000;
        if (this.performanceHistory.length === 0 || 
            secondsElapsed - this.performanceHistory[this.performanceHistory.length - 1].time >= 0.5) {
            this.performanceHistory.push({
                time: secondsElapsed,
                performance: currentFps,
                metric: 'FPS'
            });

            updatePerformanceChart(this.performanceHistory);
        }

                   this.updateUIStats(currentFps);
    }

               this.elapsedTime = Math.floor((now - this.startTime) / 1000);

               if (this.elapsedTime >= this.testDuration) {
        this.stop();
        return;
    }

               requestAnimationFrame(this.render.bind(this));
}
            stop() {
                super.stop();
                
                if (this.testResults) {
                    this.testResults.particleCount = this.particleCount;
                    this.testResults.resolution = this.resolution;
                }
                
                logToConsole('GPU test completed', 'info');
            }
        }

        class CPUSingleThreadTest extends BaseTest {
            constructor() {
                super();
                this.canvas = document.getElementById('cpuCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.iterationCount = 1000;
                this.particles = [];
                
                this.detectCPU();
                this.resize();
                
                window.addEventListener('resize', () => this.resize());
                
                logToConsole('CPU single thread test initialized', 'info');
            }
            
            detectCPU() {
                const cpuInfo = `CPU (${navigator.hardwareConcurrency || 'Unknown'} logical cores)`;
                document.getElementById('hardware-info').textContent = cpuInfo;
                logToConsole(`Detected ${cpuInfo}`, 'info');
            }
            
            resize() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                
                if (this.canvas.width !== width || this.canvas.height !== height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                }
            }
            
            initParticles() {
                this.particles = [];
                const particleCount = 1000;

                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: Math.random() * 3 + 1,
                        color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                        vx: Math.random() * 2 - 1,
                        vy: Math.random() * 2 - 1
                    });
                }
            }
            
            drawParticles(time) {
                if (!this.ctx) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const angleOffset = time * 0.001 * this.complexity;
                
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];

                    p.x += p.vx + Math.sin(angleOffset + i * 0.1) * 0.5;
                    p.y += p.vy + Math.cos(angleOffset + i * 0.1) * 0.5;

                    if (p.x < 0) p.x = this.canvas.width;
                    if (p.x > this.canvas.width) p.x = 0;
                    if (p.y < 0) p.y = this.canvas.height;
                    if (p.y > this.canvas.height) p.y = 0;

                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = p.color;
                    this.ctx.fill();
                }
            }
            
           performCPUWork() {
    const startTime = performance.now();

               let result = 0;
    for (let i = 0; i < this.iterationCount; i++) {
        const size = 10 * this.complexity;
        const matrix = [];

        const cacheBreakerOffset = this.disableCache ? Math.sin(this.cacheBreaker + i * 0.01) : 0;

        for (let x = 0; x < size; x++) {
            matrix[x] = [];
            for (let y = 0; y < size; y++) {
                matrix[x][y] = Math.sin(x * y + cacheBreakerOffset) * Math.cos(x + y + cacheBreakerOffset);
            }
        }

        for (let x = 0; x < size; x++) {
            for (let y = 0; y < size; y++) {
                result += Math.sqrt(Math.pow(matrix[x][y], 2));
            }
        }
    }
    
    const endTime = performance.now();
    const duration = endTime - startTime;

               return 1000 / duration;
}
            
           start() {


               super.start();

               document.getElementById('fps-label').textContent = 'OPS:';

               this.iterationCount = parseInt(document.getElementById('iterationCount').value);
    this.disableCache = document.getElementById('disable-cache').checked;

               if (this.disableCache) {
        logToConsole('Cache disabled: Using non-cached calculations', 'info');
                   this.cacheBreaker = Math.random();
    }

               this.initParticles();

               this.lastFrameTime = performance.now();
    requestAnimationFrame(this.update.bind(this));
    
    this.testResults = {
        mode: 'cpu-single',
        disableCache: this.disableCache,
        hardware: document.getElementById('hardware-info').textContent
    };
    
    logToConsole(`Starting CPU single thread test with ${this.iterationCount} iterations (Cache Disabled: ${this.disableCache ? 'Yes' : 'No'})`, 'info');
}
            
            update(now) {
                if (!this.running) return;

                this.elapsedTime = Math.floor((now - this.startTime) / 1000);

                try {
                    const performanceValue = this.performCPUWork();

                    this.totalPerformance += performanceValue;
                    this.performanceReadings++;
                    this.minPerformance = Math.min(this.minPerformance, performanceValue);
                    this.maxPerformance = Math.max(this.maxPerformance, performanceValue);

                    const secondsElapsed = (now - this.startTime) / 1000;
                    if (this.performanceHistory.length === 0 || 
                        secondsElapsed - this.performanceHistory[this.performanceHistory.length - 1].time >= 0.5) {
                        this.performanceHistory.push({
                            time: secondsElapsed,
                            performance: performanceValue,
                            metric: 'OPS'
                        });

                        updatePerformanceChart(this.performanceHistory);
                    }

                    this.drawParticles(now);

                    this.updateUIStats(performanceValue);
                } catch (e) {
                    logToConsole(`CPU test error: ${e.message}`, 'error');
                }

                if (this.elapsedTime >= this.testDuration) {
                    this.stop();
                    return;
                }

                requestAnimationFrame(this.update.bind(this));
            }
            
            stop() {
                super.stop();
                
                if (this.testResults) {
                    this.testResults.iterationCount = this.iterationCount;
                }

                document.getElementById('fps-label').textContent = 'FPS:';
                
                logToConsole('CPU single thread test completed', 'info');
            }
        }

        class CPUMultiThreadTest extends BaseTest {
            constructor() {
                super();
                this.canvas = document.getElementById('cpuCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.iterationCount = 1000;
                this.particles = [];
                this.workers = [];
                this.threadCount = 4;
                this.pendingWorkers = 0;
                
                this.detectCPU();
                this.resize();
                
                window.addEventListener('resize', () => this.resize());
                
                logToConsole('CPU multi-thread test initialized', 'info');
            }
            
            detectCPU() {
                const cpuInfo = `CPU (${navigator.hardwareConcurrency || 'Unknown'} logical cores)`;
                document.getElementById('hardware-info').textContent = cpuInfo;
                logToConsole(`Detected ${cpuInfo}`, 'info');

                if (document.getElementById('thread-count').value === 'auto') {
                    this.threadCount = navigator.hardwareConcurrency || 4;
                } else {
                    this.threadCount = parseInt(document.getElementById('thread-count').value);
                }
            }
            
            resize() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                
                if (this.canvas.width !== width || this.canvas.height !== height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                }
            }
            
            initParticles() {
                this.particles = [];
                const particleCount = 1000;

                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: Math.random() * 3 + 1,
                        color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                        vx: Math.random() * 2 - 1,
                        vy: Math.random() * 2 - 1
                    });
                }
            }
            
            drawParticles(time) {
                if (!this.ctx) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const angleOffset = time * 0.001 * this.complexity;
                
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];

                    p.x += p.vx + Math.sin(angleOffset + i * 0.1) * 0.5;
                    p.y += p.vy + Math.cos(angleOffset + i * 0.1) * 0.5;

                    if (p.x < 0) p.x = this.canvas.width;
                    if (p.x > this.canvas.width) p.x = 0;
                    if (p.y < 0) p.y = this.canvas.height;
                    if (p.y > this.canvas.height) p.y = 0;

                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = p.color;
                    this.ctx.fill();
                }
            }
            
            createWorkers() {
                this.workers = [];
                this.pendingWorkers = this.threadCount;
                
                try {
                    for (let i = 0; i < this.threadCount; i++) {
                        const blob = new Blob([workerCode], { type: 'application/javascript' });
                        const workerUrl = URL.createObjectURL(blob);
                        
                        const worker = new Worker(workerUrl);
                        
                        worker.onmessage = (e) => {
                            const { id, result, duration } = e.data;
                            this.pendingWorkers--;

                            const ops = 1000 / duration;

                            this.workerPerformance[id] = ops;

                            if (this.pendingWorkers === 0) {
                                this.calculateAveragePerformance();
                            }
                        };
                        
                        worker.onerror = (e) => {
                            logToConsole(`Worker error: ${e.message}`, 'error');
                            this.pendingWorkers--;
                        };
                        
                        this.workers.push({
                            worker: worker,
                            id: i
                        });
                    }
                    
                    logToConsole(`Created ${this.threadCount} worker threads`, 'info');
                } catch (e) {
                    logToConsole(`Error creating workers: ${e.message}`, 'error');
                }
            }
            
            runWorkersIteration() {
                if (this.workers.length === 0) return;
                
                this.pendingWorkers = this.threadCount;
                this.workerPerformance = {};

                const iterationsPerWorker = Math.floor(this.iterationCount / this.threadCount);
                
                try {
                    this.workers.forEach(({ worker, id }) => {
                        worker.postMessage({
                            id: id,
                            iterationCount: iterationsPerWorker,
                            complexity: this.complexity
                        });
                    });
                } catch (e) {
                    logToConsole(`Error running workers: ${e.message}`, 'error');
                }
            }
            
            calculateAveragePerformance() {
                let totalPerformance = 0;
                let workerCount = 0;
                
                for (const id in this.workerPerformance) {
                    totalPerformance += this.workerPerformance[id];
                    workerCount++;
                }
                
                if (workerCount === 0) return;
                
                const averagePerformance = totalPerformance / workerCount;

                this.currentPerformance = averagePerformance;
                this.totalPerformance += averagePerformance;
                this.performanceReadings++;
                this.minPerformance = Math.min(this.minPerformance, averagePerformance);
                this.maxPerformance = Math.max(this.maxPerformance, averagePerformance);

                const secondsElapsed = (performance.now() - this.startTime) / 1000;
                if (this.performanceHistory.length === 0 || 
                    secondsElapsed - this.performanceHistory[this.performanceHistory.length - 1].time >= 0.5) {
                    this.performanceHistory.push({
                        time: secondsElapsed,
                        performance: averagePerformance,
                        metric: 'OPS'
                    });

                    updatePerformanceChart(this.performanceHistory);
                }

                this.updateUIStats(averagePerformance);
            }
            
            start() {
               
                
                super.start();

                document.getElementById('fps-label').textContent = 'OPS:';

                this.iterationCount = parseInt(document.getElementById('iterationCount').value);
                this.threadCount = document.getElementById('thread-count').value === 'auto' 
                    ? (navigator.hardwareConcurrency || 4) 
                    : parseInt(document.getElementById('thread-count').value);

                this.initParticles();
                this.createWorkers();
                this.currentPerformance = 0;

                this.lastFrameTime = performance.now();
                this.workerPerformance = {};

                this.runWorkersIteration();

                requestAnimationFrame(this.update.bind(this));
                
                this.testResults = {
                    mode: 'cpu-multi',
                    threadCount: this.threadCount,
                    hardware: document.getElementById('hardware-info').textContent
                };
                
                logToConsole(`Starting CPU multi-thread test with ${this.threadCount} threads and ${this.iterationCount} iterations`, 'info');
            }
            
            update(now) {
                if (!this.running) return;

                this.elapsedTime = Math.floor((now - this.startTime) / 1000);

                this.drawParticles(now);

                if (this.pendingWorkers === 0 && this.running) {
                    this.runWorkersIteration();
                }

                if (this.elapsedTime >= this.testDuration) {
                    this.stop();
                    return;
                }

                requestAnimationFrame(this.update.bind(this));
            }
            
            stop() {
                super.stop();

                try {
                    this.workers.forEach(({ worker }) => {
                        worker.terminate();
                    });
                } catch (e) {
                    logToConsole(`Error terminating workers: ${e.message}`, 'error');
                }
                
                this.workers = [];
                
                if (this.testResults) {
                    this.testResults.iterationCount = this.iterationCount;
                }

                document.getElementById('fps-label').textContent = 'FPS:';
                
                logToConsole('CPU multi-thread test completed', 'info');
            }
        }

        const mat4 = {
            create: function() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            },
            
            perspective: function(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) * nf;
                out[15] = 0;
                
                return out;
            },
            
            translate: function(out, a, v) {
                const x = v[0], y = v[1], z = v[2];
                
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                
                return out;
            },
            
            rotate: function(out, a, rad, axis) {
                let x = axis[0], y = axis[1], z = axis[2];
                let len = Math.sqrt(x * x + y * y + z * z);
                
                if (len < 0.000001) {
                    return a;
                }
                
                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;
                
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];

                const b00 = x * x * t + c;
                const b01 = y * x * t + z * s;
                const b02 = z * x * t - y * s;
                const b10 = x * y * t - z * s;
                const b11 = y * y * t + c;
                const b12 = z * y * t + x * s;
                const b20 = x * z * t + y * s;
                const b21 = y * z * t - x * s;
                const b22 = z * z * t + c;

                out[0] = a00 * b00 + a10 * b01 + a20 * b02;
                out[1] = a01 * b00 + a11 * b01 + a21 * b02;
                out[2] = a02 * b00 + a12 * b01 + a22 * b02;
                out[3] = a03 * b00 + a13 * b01 + a23 * b02;
                out[4] = a00 * b10 + a10 * b11 + a20 * b12;
                out[5] = a01 * b10 + a11 * b11 + a21 * b12;
                out[6] = a02 * b10 + a12 * b11 + a22 * b12;
                out[7] = a03 * b10 + a13 * b11 + a23 * b12;
                out[8] = a00 * b20 + a10 * b21 + a20 * b22;
                out[9] = a01 * b20 + a11 * b21 + a21 * b22;
                out[10] = a02 * b20 + a12 * b21 + a22 * b22;
                out[11] = a03 * b20 + a13 * b21 + a23 * b22;

                if (a !== out) {
                    out[12] = a[12];
                    out[13] = a[13];
                    out[14] = a[14];
                    out[15] = a[15];
                }
                
                return out;
            }
        };

        let performanceChart = null;
        let distributionChart = null;
        let historyChart = null;
        
        function setupCharts() {
            const perfCtx = document.getElementById('performanceChart').getContext('2d');
            performanceChart = new Chart(perfCtx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Performance',
                        data: [],
                        borderColor: '#4a6cf7',
                        backgroundColor: 'rgba(74, 108, 247, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (seconds)'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Performance'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const metric = context.dataset.metric || 'Performance';
                                    return `${metric}: ${context.parsed.y.toFixed(1)}`;
                                }
                            }
                        }
                    }
                }
            });

            const distCtx = document.getElementById('distributionChart').getContext('2d');
            distributionChart = new Chart(distCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Performance Distribution',
                        data: [],
                        backgroundColor: 'rgba(74, 108, 247, 0.7)',
                        borderColor: '#4a6cf7',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Range'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        }
                    }
                }
            });

            const histCtx = document.getElementById('historyChart').getContext('2d');
            historyChart = new Chart(histCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Score',
                        data: [],
                        backgroundColor: 'rgba(74, 108, 247, 0.7)',
                        borderColor: '#4a6cf7',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Score'
                            }
                        }
                    }
                }
            });
        }
        
        function updatePerformanceChart(performanceData) {
            if (!performanceChart || performanceData.length === 0) return;
            
            try {
                const metric = performanceData[0].metric || 'Performance';
                
                performanceChart.data.datasets[0].data = performanceData.map(point => ({
                    x: point.time,
                    y: point.performance
                }));
                
                performanceChart.data.datasets[0].metric = metric;
                performanceChart.options.scales.y.title.text = metric;
                
                performanceChart.update();
            } catch (e) {
                logToConsole(`Error updating performance chart: ${e.message}`, 'error');
            }
        }
        
        function updateDistributionChart(performanceData) {
            if (!distributionChart || performanceData.length === 0) return;
            
            try {
                const bucketSize = 10;
                const buckets = {};
                const min = Math.floor(Math.min(...performanceData.map(d => d.performance)) / bucketSize) * bucketSize;
                const max = Math.ceil(Math.max(...performanceData.map(d => d.performance)) / bucketSize) * bucketSize;
                
                for (let i = min; i <= max; i += bucketSize) {
                    buckets[i] = 0;
                }

                performanceData.forEach(data => {
                    const bucketKey = Math.floor(data.performance / bucketSize) * bucketSize;
                    if (buckets[bucketKey] !== undefined) {
                        buckets[bucketKey]++;
                    }
                });

                distributionChart.data.labels = Object.keys(buckets).map(key => `${key}-${parseInt(key) + bucketSize}`);
                distributionChart.data.datasets[0].data = Object.values(buckets);
                
                const metric = performanceData[0].metric || 'Performance';
                distributionChart.data.datasets[0].label = `${metric} Distribution`;
                
                distributionChart.update();
            } catch (e) {
                logToConsole(`Error updating distribution chart: ${e.message}`, 'error');
            }
        }
        
        function updateHistoryView() {
            const data = getAllTestResults();
            const days = Object.keys(data).sort();
            
            if (days.length === 0) {
                historyChart.data.labels = [];
                historyChart.data.datasets[0].data = [];
                historyChart.update();
                return;
            }
            
            try {
                const dailyScores = days.map(day => {
                    const tests = data[day];
                    if (!tests || tests.length === 0) return 0;
                    
                    const total = tests.reduce((sum, test) => sum + (test.score || 0), 0);
                    return Math.round(total / tests.length);
                });
                
                historyChart.data.labels = days;
                historyChart.data.datasets[0].data = dailyScores;
                historyChart.update();

                const tableBody = document.getElementById('history-table-body');
                tableBody.innerHTML = '';
                
                if (days.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No data available</td></tr>';
                    return;
                }
                
                days.forEach(day => {
                    const tests = data[day];
                    if (!tests || tests.length === 0) return;
                    
                    tests.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    
                    tests.forEach(test => {
                        const row = document.createElement('tr');
                        
                        const timeStr = new Date(test.timestamp).toLocaleTimeString();

                        let modeText = 'GPU';
                        if (test.mode === 'cpu-single') {
                            modeText = 'CPU (Single Thread)';
                        } else if (test.mode === 'cpu-multi') {
                            modeText = `CPU (${test.threadCount} Threads)`;
                        } else if (test.renderApi) {
                            modeText = `GPU (${test.renderApi})`;
                        }
                        
                        row.innerHTML = `
                            <td>${day} ${timeStr}</td>
                            <td>${modeText}</td>
                            <td>${formatNumber(test.score || 0)}</td>
                            <td>${(test.avgPerformance || 0).toFixed(1)} ${test.performanceData?.[0]?.metric || 'FPS'}</td>
                            <td>${formatTime(test.duration || 0)}</td>
                            <td>
                                <button class="btn btn-sm" data-test-id="${test.id}" style="padding: 5px 10px; font-size: 0.8rem;">
                                    View Details
                                </button>
                            </td>
                        `;
                        
                        tableBody.appendChild(row);
                    });
                });

                document.querySelectorAll('[data-test-id]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const testId = parseInt(btn.getAttribute('data-test-id'));
                        viewTestDetails(testId);
                    });
                });
            } catch (e) {
                logToConsole(`Error updating history view: ${e.message}`, 'error');
            }
        }
        
        function viewTestDetails(testId) {
            const data = getAllTestResults();
            let test = null;

            for (const day in data) {
                const found = data[day].find(t => t.id === testId);
                if (found) {
                    test = found;
                    break;
                }
            }
            
            if (!test) {
                alert('Test details not found');
                return;
            }
            
            try {
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                modal.style.display = 'flex';
                modal.style.justifyContent = 'center';
                modal.style.alignItems = 'center';
                modal.style.zIndex = '999';
                
                const modalContent = document.createElement('div');
                modalContent.style.backgroundColor = 'var(--card-bg)';
                modalContent.style.borderRadius = '12px';
                modalContent.style.padding = '25px';
                modalContent.style.width = '80%';
                modalContent.style.maxWidth = '800px';
                modalContent.style.maxHeight = '80%';
                modalContent.style.overflow = 'auto';
                modalContent.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.2)';

                let modeText = 'GPU';
                if (test.mode === 'cpu-single') {
                    modeText = 'CPU (Single Thread)';
                } else if (test.mode === 'cpu-multi') {
                    modeText = `CPU (${test.threadCount} Threads)`;
                } else if (test.renderApi) {
                    modeText = `GPU (${test.renderApi})`;
                }

                const metricName = test.performanceData?.[0]?.metric || 'FPS';

                modalContent.innerHTML = `
                    <h2 style="color: var(--primary); margin-bottom: 20px;">Test Details</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
                        <div>
                            <p><strong>Date:</strong> ${new Date(test.timestamp).toLocaleString()}</p>
                            <p><strong>Mode:</strong> ${modeText}</p>
                            <p><strong>Score:</strong> ${formatNumber(test.score || 0)}</p>
                            <p><strong>Avg ${metricName}:</strong> ${(test.avgPerformance || 0).toFixed(1)}</p>
                            <p><strong>Min ${metricName}:</strong> ${(test.minPerformance || 0).toFixed(1)}</p>
                            <p><strong>Max ${metricName}:</strong> ${(test.maxPerformance || 0).toFixed(1)}</p>
                        </div>
                        <div>
                            <p><strong>Duration:</strong> ${formatTime(test.duration || 0)}</p>
                            <p><strong>Complexity:</strong> ${test.complexity || 'N/A'}</p>
                            ${test.particleCount ? `<p><strong>Particles:</strong> ${formatNumber(test.particleCount)}</p>` : ''}
                            ${test.resolution ? `<p><strong>Resolution:</strong> ${test.resolution}x</p>` : ''}
                            ${test.iterationCount ? `<p><strong>Iterations:</strong> ${formatNumber(test.iterationCount)}</p>` : ''}
                            <p><strong>Hardware:</strong> ${test.hardware || 'Unknown'}</p>
                        </div>
                    </div>
                    <div style="height: 300px; margin-bottom: 25px;">
                        <canvas id="detailChart"></canvas>
                    </div>
                    <button id="closeModal" class="btn" style="margin-top: 15px;">Close</button>
                `;
                
                modal.appendChild(modalContent);
                document.body.appendChild(modal);

                if (test.performanceData && test.performanceData.length > 0) {
                    const ctx = document.getElementById('detailChart').getContext('2d');
                    const detailChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: metricName,
                                data: test.performanceData.map(point => ({
                                    x: point.time,
                                    y: point.performance
                                })),
                                borderColor: '#4a6cf7',
                                backgroundColor: 'rgba(74, 108, 247, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'linear',
                                    title: {
                                        display: true,
                                        text: 'Time (seconds)'
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: metricName
                                    }
                                }
                            }
                        }
                    });
                }

                document.getElementById('closeModal').addEventListener('click', () => {
                    document.body.removeChild(modal);
                });

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                });
            } catch (e) {
                logToConsole(`Error displaying test details: ${e.message}`, 'error');
            }
        }

        function applyTheme(theme) {
            if (theme === 'dark' || (theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }
        
        function setupThemeHandling() {
            const themeSelect = document.getElementById('theme');

            const savedTheme = localStorage.getItem('stressTestTheme') || 'light';
            themeSelect.value = savedTheme;
            applyTheme(savedTheme);

            themeSelect.addEventListener('change', () => {
                const theme = themeSelect.value;
                localStorage.setItem('stressTestTheme', theme);
                applyTheme(theme);
            });

            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
                if (themeSelect.value === 'auto') {
                    applyTheme('auto');
                }
            });
        }

        function setupTestModeHandling() {
    const radioButtons = document.querySelectorAll('input[name="test-mode"]');

            const initialMode = document.querySelector('input[name="test-mode"]:checked').value;
    updateUIForMode(initialMode);
    
    radioButtons.forEach(radio => {
        radio.addEventListener('change', () => {
            const mode = radio.value;
            updateUIForMode(mode);
            logToConsole(`Test mode changed to ${mode}`, 'info');
        });
    });
    
    function updateUIForMode(mode) {
        document.getElementById('gpu-options').style.display = 'none';
        document.getElementById('cpu-options').style.display = 'none';
        document.getElementById('thread-count-container').style.display = 'none';
        document.getElementById('particle-setting').style.display = 'none';
        document.getElementById('resolution-setting').style.display = 'none';
        document.getElementById('iteration-setting').style.display = 'none';
        document.getElementById('antialiasing-setting').style.display = 'none';

        if (mode === 'cpu-multi') {
            document.getElementById('cpu-options').style.display = 'block';
            document.getElementById('thread-count-container').style.display = 'block';
            document.getElementById('iteration-setting').style.display = 'block';

            document.getElementById('glCanvas').style.display = 'none';
            document.getElementById('cpuCanvas').style.display = 'block';
        } else if (mode === 'cpu-single') {
            document.getElementById('cpu-options').style.display = 'block';
            document.getElementById('iteration-setting').style.display = 'block';
            document.getElementById('thread-count-container').style.display = 'none';

            document.getElementById('glCanvas').style.display = 'none';
            document.getElementById('cpuCanvas').style.display = 'block';
        } else {
            document.getElementById('gpu-options').style.display = 'block';
            document.getElementById('particle-setting').style.display = 'block';
            document.getElementById('resolution-setting').style.display = 'block';
            document.getElementById('antialiasing-setting').style.display = 'block';

            document.getElementById('glCanvas').style.display = 'block';
            document.getElementById('cpuCanvas').style.display = 'none';
        }
    }
}

        function createTestInstance() {
            try {
                const mode = document.querySelector('input[name="test-mode"]:checked').value;
                
                if (mode === 'gpu') {
                    const renderApi = document.getElementById('render-api').value;
                    return new GPUTest(renderApi);
                } else if (mode === 'cpu-single') {
                    return new CPUSingleThreadTest();
                } else if (mode === 'cpu-multi') {
                    return new CPUMultiThreadTest();
                }
            } catch (e) {
                logToConsole(`Error creating test instance: ${e.message}`, 'error');
                return null;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                setupTabs();
                setupCharts();
                setupThemeHandling();
                setupTestModeHandling();

                if (!window.navigator.gpu) {
                    const webGpuOption = document.querySelector('option[value="webgpu"]');
                    if (webGpuOption) {
                        webGpuOption.disabled = true;
                        webGpuOption.text = 'WebGPU (Not Supported)';
                    }
                    logToConsole('WebGPU is not supported in this browser', 'warn');
                }

                const cpuCores = navigator.hardwareConcurrency || 'unknown';
                logToConsole(`Detected ${cpuCores} logical CPU cores`, 'info');

                let currentTest = null;

                document.getElementById('start-btn').addEventListener('click', () => {
                    document.getElementById('start-btn').disabled = true;

                    currentTest = createTestInstance();
                    if (currentTest) {
                        currentTest.start();
                    } else {
                        logToConsole('Failed to initialize test', 'error');
                        document.getElementById('start-btn').disabled = false;
                    }
                });
                
                document.getElementById('stop-btn').addEventListener('click', () => {
                    if (currentTest) {
                        currentTest.stop();
                    }
                });
                
                document.getElementById('save-btn').addEventListener('click', () => {
                    if (currentTest) {
                        currentTest.saveResults();
                    }
                });
                
                document.getElementById('clearData').addEventListener('click', clearAllData);
                document.getElementById('exportData').addEventListener('click', exportData);

                document.getElementById('render-api').addEventListener('change', function() {
                    logToConsole(`Rendering API changed to ${this.value}`, 'info');
                });

                document.getElementById('thread-count').addEventListener('change', function() {
                    const value = this.value;
                    const displayValue = value === 'auto' ? 
                        `Auto (${navigator.hardwareConcurrency || 4} cores)` : 
                        `${value} threads`;
                    logToConsole(`Thread count set to ${displayValue}`, 'info');
                });

                document.querySelectorAll('input[type="range"]').forEach(input => {
                    input.addEventListener('input', () => {
                        if (input.id === 'particleCount') {
                            const value = parseInt(input.value).toLocaleString();
                            logToConsole(`Particle count set to ${value}`, 'info');
                        } else if (input.id === 'complexity') {
                            logToConsole(`Complexity set to ${input.value}/10`, 'info');
                        } else if (input.id === 'resolution') {
                            logToConsole(`Resolution scale set to ${input.value}x`, 'info');
                        } else if (input.id === 'durationSlider') {
                            logToConsole(`Test duration set to ${input.value} seconds`, 'info');
                        } else if (input.id === 'iterationCount') {
                            logToConsole(`Iteration count set to ${input.value}`, 'info');
                        }
                    });
                });

                updateHistoryView();

                const userAgent = navigator.userAgent;
                logToConsole(`Browser: ${userAgent}`, 'info');

                let webglSupported = false;
                try {
                    const canvas = document.createElement('canvas');
                    webglSupported = !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                } catch (e) {
                    webglSupported = false;
                }
                
                if (!webglSupported) {
                    logToConsole('WARNING: WebGL is not supported or enabled in this browser!', 'error');
                    document.getElementById('gpu-mode').disabled = true;
                    document.getElementById('cpu-single-mode').checked = true;
                    document.getElementById('cpu-single-mode').dispatchEvent(new Event('change'));
                } else {
                    logToConsole('WebGL is supported in this browser', 'info');
                }
                
                logToConsole('System initialized and ready', 'info');
            } catch (e) {
                logToConsole(`Error during initialization: ${e.message}`, 'error');
                console.error(e);
            }
        });
    </script>
</body>
</html>