<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU/CPU Stress Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="speedometer.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #4a6cf7;
            --primary-dark: #3a5bd9;
            --secondary: #6c757d;
            --danger: #dc3545;
            --success: #28a745;
            --warning: #ffc107;
            --dark: #343a40;
            --light: #f8f9fa;
            --background: #f8f9fa;
            --card-bg: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background);
            color: var(--dark);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .header p {
            font-size: 1.2rem;
            color: var(--secondary);
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 25px;
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.15);
        }

        .card-header {
            font-size: 1.5rem;
            font-weight: 500;
            margin-bottom: 20px;
            color: var(--primary);
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }

        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .setting-group select,
        .setting-group input {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            background-color: var(--card-bg);
            color: var(--dark);
        }

        .setting-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
            padding: 0;
            border: none;
        }

        .setting-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        .range-value {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            color: var(--secondary);
            font-size: 0.9rem;
        }

        .btn {
            display: inline-block;
            font-weight: 500;
            color: #fff;
            text-align: center;
            vertical-align: middle;
            cursor: pointer;
            background-color: var(--primary);
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            line-height: 1.5;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }

        .btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-danger {
            background-color: var(--danger);
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-success {
            background-color: var(--success);
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.2);
        }

        .stat-card h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .stat-card .value {
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .canvas-container {
            position: relative;
            height: 300px;
            width: 100%;
            margin: 20px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 30px;
            background-color: var(--card-bg);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .tab {
            padding: 12px 20px;
            background-color: transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .tab:hover {
            background-color: rgba(74, 108, 247, 0.1);
        }

        .tab.active {
            background-color: var(--primary);
            color: white;
            box-shadow: 0 4px 8px rgba(74, 108, 247, 0.3);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: 6px 12px;
            font-size: 0.8rem;
            font-weight: 700;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 50px;
            color: #fff;
            background-color: var(--primary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .badge-success {
            background-color: var(--success);
        }

        .badge-danger {
            background-color: var(--danger);
        }

        .badge-warning {
            background-color: var(--warning);
            color: #212529;
        }

        .progress {
            position: relative;
            height: 12px;
            overflow: hidden;
            background-color: #e9ecef;
            border-radius: 50px;
            margin-bottom: 15px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: transparent;
            font-size: 0.8rem;
            border-radius: 50px;
            position: relative;
            overflow: hidden;
        }

        .progress-text {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--dark);
            font-weight: 500;
            font-size: 0.75rem;
            z-index: 2;
            pointer-events: none;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        table th, table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        table th {
            background-color: #f5f5f5;
            font-weight: 600;
            color: var(--primary);
        }

        table tr:last-child td {
            border-bottom: none;
        }

        table tr:hover td {
            background-color: rgba(74, 108, 247, 0.05);
        }

        #glCanvas, #cpuCanvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 12px;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 300px;
            overflow: hidden;
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
        }

        .overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
        }

        .dark-mode {
            --background: #1a1a1a;
            --card-bg: #2a2a2a;
            --dark: #f8f9fa;
            --light: #343a40;
            --secondary: #adb5bd;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .console {
            background-color: #1a1a1a;
            color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
        }

        .log {
            margin-bottom: 5px;
            line-height: 1.4;
        }

        .log-info {
            color: #4a6cf7;
        }

        .log-warn {
            color: #ffc107;
        }

        .log-error {
            color: #dc3545;
        }

        .range-current-value {
            font-weight: bold;
            text-align: center;
            margin-top: 5px;
        }

        .speedometer-container {
            position: relative;
            width: 250px;
            height: 250px;
            margin: 20px auto;
        }

        .speedometer {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: #f3f3f3;
            border: 10px solid #ddd;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .speedometer-center {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #333;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .speedometer-needle {
            position: absolute;
            width: 5px;
            height: 110px;
            background: #ff3b30;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -100%) rotate(0deg);
            transform-origin: bottom center;
            border-radius: 5px;
            z-index: 5;
            transition: transform 1s ease-in-out;
        }

        .speedometer-scale {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .speedometer-value {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 30px;
            font-weight: bold;
            color: #333;
        }

        .speedometer-unit {
            font-size: 18px;
            color: #666;
        }

        .speedometer-tick {
            position: absolute;
            width: 4px;
            height: 10px;
            background: #333;
            transform-origin: center 115px;
            left: calc(50% - 2px);
            top: 10px;
        }

        .speedometer-tick.major {
            height: 15px;
            width: 6px;
            left: calc(50% - 3px);
        }

        .speedometer-label {
            position: absolute;
            font-size: 12px;
            color: #333;
            transform-origin: center 115px;
            width: 40px;
            text-align: center;
            left: calc(50% - 20px);
            top: 30px;
        }

        .speedometer-type {
            position: absolute;
            top: 80px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
        }

        .speedometer.download {
            border-color: #4a6cf7;
        }

        .speedometer.upload {
            border-color: #ff6384;
        }

        .speedometer.download .speedometer-needle {
            background: #4a6cf7;
        }

        .speedometer.upload .speedometer-needle {
            background: #ff6384;
        }

        .speedometer-server {
            position: absolute;
            top: 15px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #333;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 3px 0;
            border-radius: 4px;
            margin: 0 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .network-results {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: rgba(0,0,0,0.05);
            border-radius: 10px;
        }

        .network-result-item {
            display: inline-block;
            margin: 0 20px;
            text-align: center;
        }

        .network-result-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .network-result-label {
            font-size: 14px;
            color: var(--secondary);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .testing {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>GPU/CPU Stress Test</h1>
        <p>Test your GPU and CPU performance with customizable settings</p>
    </div>

    <div class="tabs">
        <div class="tab active" data-tab="test">Test</div>
        <div class="tab" data-tab="stats">Statistics</div>
        <div class="tab" data-tab="history">History</div>
        <div class="tab" data-tab="settings">Settings</div>
    </div>

    <div class="tab-content active" id="test-tab">
        <div class="card">
            <div class="card-header">Test Mode Selection</div>
            <div class="radio-group">
                <div class="radio-item">
                    <input type="radio" id="gpu-mode" name="test-mode" value="gpu" checked>
                    <label for="gpu-mode">GPU</label>
                </div>
                <div class="radio-item">
                    <input type="radio" id="cpu-single-mode" name="test-mode" value="cpu-single">
                    <label for="cpu-single-mode">CPU (Single Thread)</label>
                </div>
                <div class="radio-item">
                    <input type="radio" id="cpu-multi-mode" name="test-mode" value="cpu-multi">
                    <label for="cpu-multi-mode">CPU (Multi-Thread)</label>
                </div>
                <div class="radio-item">
                    <input type="radio" id="memory-mode" name="test-mode" value="memory">
                    <label for="memory-mode">Memory</label>
                </div>
                <div class="radio-item">
                    <input type="radio" id="network-mode" name="test-mode" value="network">
                    <label for="network-mode">Network Speed</label>
                </div>
            </div>

            <div id="gpu-options">
                <div class="setting-group">
                    <label for="render-api">Rendering API</label>
                    <select id="render-api">
                        <option value="webgl1">WebGL 1</option>
                        <option value="webgl2">WebGL 2</option>
                        <option value="webgpu">WebGPU (Experimental)</option>
                    </select>
                </div>
            </div>

            <div id="cpu-options" style="display: none;">
                <div class="setting-group" id="thread-count-container">
                    <label for="thread-count">Thread Count (Multi-threaded mode)</label>
                    <select id="thread-count">
                        <option value="2">2 Threads</option>
                        <option value="4" selected>4 Threads</option>
                        <option value="8">8 Threads</option>
                        <option value="16">16 Threads</option>
                        <option value="auto">Auto (Based on CPU cores)</option>
                    </select>
                </div>

            </div>

            <div id="memory-options" style="display: none;">
                <div class="setting-group">
                    <label for="memory-test-type">Memory test type</label>
                    <select id="memory-test-type">
                        <option value="allocation">Allocation test</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label for="memory-size">Data size (MB)</label>
                    <input type="range" id="memory-size" min="16" max="4096" step="16" value="256">
                    <div class="range-value">
                        <span>16 MB</span>
                        <span>2048 MB</span>
                        <span>4096 MB</span>
                    </div>
                </div>
            </div>

            <div id="network-options" style="display: none;">
                <div class="setting-group">
                    <p>The internet speed test measures:</p>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>Connection delay (ping)</li>
                        <li>Download Speed</li>
                        <li>Upload speed</li>
                    </ul>
                    <p>Press “Start Test” to start the test.</p>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">Stress Test Visualization</div>
            <div class="canvas-wrapper">
                <canvas id="glCanvas"></canvas>
                <canvas id="cpuCanvas" style="display: none;"></canvas>
                <div id="network-test-container" style="display: none; width: 100%; text-align: center;">
                    <div class="speedometer-container">
                        <div class="speedometer download">
                            <div class="speedometer-scale" id="speedometer-scale"></div>
                            <div class="speedometer-needle"></div>
                            <div class="speedometer-center"></div>
                            <div class="speedometer-type">Download</div>
                            <div class="speedometer-server" id="server-info">Server Selection...</div>
                        </div>
                        <div class="speedometer-value">0 <span class="speedometer-unit">Mbps</span></div>
                    </div>

                    <div class="network-results">
                        <div class="network-result-item">
                            <div class="network-result-value" id="ping-value">-</div>
                            <div class="network-result-label">Ping</div>
                        </div>
                        <div class="network-result-item">
                            <div class="network-result-value" id="download-value">-</div>
                            <div class="network-result-label">Download</div>
                        </div>
                        <div class="network-result-item">
                            <div class="network-result-value" id="upload-value">-</div>
                            <div class="network-result-label">Upload</div>
                        </div>
                    </div>

                    <div id="network-result-details" style="margin-top: 20px; display: none;">
                        <h3 style="margin-bottom: 15px;">Detailed information</h3>
                        <table class="network-result-table" style="width: 100%; margin-bottom: 15px;">
                            <tr>
                                <th>Measurement</th>
                                <th>Result</th>
                                <th>Evaluation</th>
                            </tr>
                            <tr>
                                <td>Ping</td>
                                <td id="ping-detail">-</td>
                                <td id="ping-rating">-</td>
                            </tr>
                            <tr>
                                <td>Download</td>
                                <td id="download-detail">-</td>
                                <td id="download-rating">-</td>
                            </tr>
                            <tr>
                                <td>Upload</td>
                                <td id="upload-detail">-</td>
                                <td id="upload-rating">-</td>
                            </tr>
                            <tr>
                                <td>Server</td>
                                <td id="server-detail" colspan="2">-</td>
                            </tr>
                        </table>

                        <div style="font-size: 12px; color: #666; margin-top: 10px;">
                            <p>Characteristics to evaluate:</p>
                            <ul style="padding-left: 20px; margin-top: 5px;">
                                <li>Great: Ping < 20ms, Download > 50 Mbps, Upload > 25 Mbps</li>
                                <li>Good: Ping < 50ms, Download > 25 Mbps, Upload > 10 Mbps</li>
                                <li>Ok: Ping < 100ms, Download > 10 Mbps, Upload > 5 Mbps</li>
                                <li>Bad: Ping > 100ms, Download < 10 Mbps, Upload < 5 Mbps</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="overlay">
                    <span id="fps-label">FPS:</span> <span id="fps">0</span> |
                    <span id="temp-label">Temperature:</span> <span id="temperature">0°C</span> |
                    <span id="load-label">Load:</span> <span id="load">0%</span>
                </div>
            </div>

            <div class="progress">
                <div class="progress-bar" id="test-progress" style="width: 0%"></div>
                <div class="progress-text">0%</div>
            </div>

            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div>
                    <span class="badge" id="status-badge">Ready</span>
                    <span style="margin-left: 10px;">Duration: <span id="duration">00:00</span></span>
                </div>
                <div>
                    <span>Hardware: <span id="hardware-info">Detecting...</span></span>
                </div>
            </div>

            <div class="btn-container">
                <button class="btn btn-success" id="start-btn">Start Test</button>
                <button class="btn btn-danger" id="stop-btn" disabled>Stop Test</button>
                <button class="btn" id="save-btn" disabled>Save Results</button>
            </div>
        </div>

        <div class="card">
            <div class="card-header">Test Settings</div>
            <div class="settings">
                <div class="setting-group">
                    <label for="complexity">Workload Complexity</label>
                    <input type="range" id="complexity" min="1" max="20" value="10">
                    <div class="range-value">
                        <span>Low</span>
                        <span>Medium</span>
                        <span>High</span>
                    </div>
                </div>
                <div class="setting-group" id="antialiasing-setting">
                    <label for="antialiasing">Antialiasing</label>
                    <select id="antialiasing">
                        <option value="none">None</option>
                        <option value="msaa2x">MSAA 2x</option>
                        <option value="msaa4x">MSAA 4x</option>
                        <option value="msaa8x">MSAA 8x</option>
                        <option value="msaa16x">MSAA 16x</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label for="disable-cache">Disable Browser Caching</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="disable-cache" style="width: auto;">
                        <label for="disable-cache" style="margin: 0;">Enable for more accurate testing</label>
                    </div>
                </div>
                <div class="setting-group" id="particle-setting">
                    <label for="particleCount">Particle Count (GPU)</label>
                    <input type="range" id="particleCount" min="10000" max="10000000" step="10000" value="1000000">
                    <div class="range-value">
                        <span>10,000</span>
                        <span>5,000,000</span>
                        <span>10,000,000</span>
                    </div>
                </div>
                <div class="setting-group" id="iteration-setting" style="display: none;">
                    <label for="iterationCount">Iterations (CPU)</label>
                    <input type="range" id="iterationCount" min="10" max="5000" step="10" value="1000">
                    <div class="range-value">
                        <span>10</span>
                        <span>2,500</span>
                        <span>5,000</span>
                    </div>
                </div>
                <div class="setting-group">
                    <label for="duration">Test Duration (seconds)</label>
                    <input type="range" id="durationSlider" min="10" max="300" step="10" value="60">
                    <div class="range-value">
                        <span>10s</span>
                        <span>150s</span>
                        <span>300s</span>
                    </div>
                </div>
                <div class="setting-group" id="resolution-setting">
                    <label for="resolution">Render Resolution (GPU)</label>
                    <input type="range" id="resolution" min="0.25" max="4" step="0.25" value="1">
                    <div class="range-value">
                        <span>25%</span>
                        <span>100%</span>
                        <span>400%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">Real-time Performance</div>
            <div class="canvas-container">
                <canvas id="performanceChart"></canvas>
            </div>
        </div>

        <div class="card">
            <div class="card-header">Console Output</div>
            <div class="console" id="console-output">
                <div class="log log-info">System initialized. Ready to start test.</div>
            </div>
        </div>
    </div>

    <div class="tab-content" id="stats-tab">
        <div class="card">
            <div class="card-header">Current Test Statistics</div>
            <div class="stats-container">
                <div class="stat-card">
                    <h3>Avg Performance</h3>
                    <div class="value" id="avg-fps">0</div>
                </div>
                <div class="stat-card">
                    <h3>Min Performance</h3>
                    <div class="value" id="min-fps">0</div>
                </div>
                <div class="stat-card">
                    <h3>Max Performance</h3>
                    <div class="value" id="max-fps">0</div>
                </div>
                <div class="stat-card">
                    <h3>Score</h3>
                    <div class="value" id="score">0</div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">Performance Analysis</div>
            <div class="canvas-container">
                <canvas id="distributionChart"></canvas>
            </div>
        </div>
    </div>

    <div class="tab-content" id="history-tab">
        <div class="card">
            <div class="card-header">Historical Performance</div>
            <div class="canvas-container">
                <canvas id="historyChart"></canvas>
            </div>
            <div class="historical-data">
                <table>
                    <thead>
                    <tr>
                        <th>Date</th>
                        <th>Mode</th>
                        <th>Score</th>
                        <th>Avg Performance</th>
                        <th>Duration</th>
                        <th>Actions</th>
                    </tr>
                    </thead>
                    <tbody id="history-table-body">
                    <tr>
                        <td colspan="6" style="text-align: center;">No data available</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>



    <div class="tab-content" id="settings-tab">
        <div class="card">
            <div class="card-header">Application Settings</div>
            <div class="settings">
                <div class="setting-group">
                    <label for="theme">Theme</label>
                    <select id="theme">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="auto">System Default</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label for="dataRetention">Data Retention (days)</label>
                    <input type="range" id="dataRetention" min="7" max="90" step="7" value="30">
                    <div class="range-value">
                        <span>7 days</span>
                        <span>30 days</span>
                        <span>90 days</span>
                    </div>
                </div>
            </div>
            <div class="btn-container">
                <button class="btn" id="clearData">Clear All Data</button>
                <button class="btn" id="exportData">Export Data</button>
            </div>
        </div>

        <div class="card">
            <div class="card-header">About</div>
            <p>GPU/CPU Stress Test v1.0.0</p>
            <p style="margin-top: 10px;">This tool uses WebGL/WebGPU to test your GPU's performance and JavaScript to test your CPU performance under load.</p>
            <p style="margin-top: 10px;">Note: Results are stored locally in your browser and are not sent to any server.</p>
        </div>
    </div>
</div>

<script>
    const consoleOutput = document.getElementById('console-output');

    function logToConsole(message, type = 'info') {
        const logElement = document.createElement('div');
        logElement.className = `log log-${type}`;
        logElement.textContent = message;
        consoleOutput.appendChild(logElement);
        consoleOutput.scrollTop = consoleOutput.scrollHeight;

        if (type === 'error') {
            console.error(message);
        } else if (type === 'warn') {
            console.warn(message);
        } else {
            console.log(message);
        }
    }

    const workerCode = `
            self.onmessage = function(e) {
                const { id, iterationCount, complexity } = e.data;
                
                const startTime = performance.now();
                
                // Perform complex calculations
                let result = 0;
                for (let i = 0; i < iterationCount; i++) {
                    // Matrix operations (complexity affects size)
                    const size = 10 * complexity;
                    const matrix = [];
                    
                    // Initialize matrix
                    for (let x = 0; x < size; x++) {
                        matrix[x] = [];
                        for (let y = 0; y < size; y++) {
                            matrix[x][y] = Math.sin(x * y) * Math.cos(x + y);
                        }
                    }
                    
                    // Process matrix
                    for (let x = 0; x < size; x++) {
                        for (let y = 0; y < size; y++) {
                            result += Math.sqrt(Math.pow(matrix[x][y], 2));
                        }
                    }
                }
                
                const duration = performance.now() - startTime;
                
                self.postMessage({
                    id,
                    result,
                    duration
                });
            };
        `;

    function formatNumber(num) {
        return num.toLocaleString('en-US', { maximumFractionDigits: 2 });
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function getDateString(date) {
        return date.toISOString().split('T')[0];
    }

    function getCurrentDate() {
        return getDateString(new Date());
    }

    const storageKey = 'stressTest';

    function saveTestResults(results) {
        const storage = localStorage.getItem(storageKey);
        let data = storage ? JSON.parse(storage) : {};

        const today = getCurrentDate();
        if (!data[today]) {
            data[today] = [];
        }

        results.id = Date.now();
        results.timestamp = new Date().toISOString();
        data[today].push(results);

        localStorage.setItem(storageKey, JSON.stringify(data));
        updateHistoryView();
        logToConsole(`Results saved with ID: ${results.id}`, 'info');
    }

    function getAllTestResults() {
        const storage = localStorage.getItem(storageKey);
        return storage ? JSON.parse(storage) : {};
    }

    function clearAllData() {
        if (confirm('Are you sure you want to delete all saved test results? This action cannot be undone.')) {
            localStorage.removeItem(storageKey);
            updateHistoryView();
            logToConsole('All data cleared from local storage', 'info');
        }
    }

    function exportData() {
        const data = getAllTestResults();
        const dataStr = JSON.stringify(data, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `stress_test_export_${getCurrentDate()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        logToConsole('Data exported successfully', 'info');
    }

    function setupTabs() {
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                tab.classList.add('active');
                const tabId = `${tab.getAttribute('data-tab')}-tab`;
                document.getElementById(tabId).classList.add('active');
            });
        });
    }

    class BaseTest {
        constructor() {
            this.running = false;
            this.startTime = 0;
            this.frames = 0;
            this.fps = 0;
            this.performanceHistory = [];
            this.testDuration = 60;
            this.elapsedTime = 0;
            this.complexity = 5;

            this.lastFrameTime = 0;
            this.minPerformance = Infinity;
            this.maxPerformance = 0;
            this.totalPerformance = 0;
            this.performanceReadings = 0;
        }

        start() {
            if (this.running) return;

            this.running = true;
            this.startTime = performance.now();
            this.frames = 0;
            this.elapsedTime = 0;
            this.performanceHistory = [];
            this.minPerformance = Infinity;
            this.maxPerformance = 0;
            this.totalPerformance = 0;
            this.performanceReadings = 0;

            document.getElementById('status-badge').textContent = 'Running';
            document.getElementById('status-badge').className = 'badge badge-warning';
            document.getElementById('start-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
            document.getElementById('save-btn').disabled = true;

            this.testDuration = parseInt(document.getElementById('durationSlider').value);
            this.complexity = parseInt(document.getElementById('complexity').value);
        }

        stop() {
            this.running = false;

            let avgPerformance = 0;
            if (this.performanceReadings > 0) {
                avgPerformance = this.totalPerformance / this.performanceReadings;
            }

            document.getElementById('status-badge').textContent = 'Completed';
            document.getElementById('status-badge').className = 'badge badge-success';
            document.getElementById('start-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
            document.getElementById('save-btn').disabled = false;

            document.getElementById('avg-fps').textContent = avgPerformance.toFixed(1);
            document.getElementById('min-fps').textContent = this.minPerformance.toFixed(1);
            document.getElementById('max-fps').textContent = this.maxPerformance.toFixed(1);

            const score = Math.round(avgPerformance * this.complexity);
            document.getElementById('score').textContent = formatNumber(score);

            this.testResults = {
                date: new Date().toISOString(),
                score: score,
                avgPerformance: avgPerformance,
                minPerformance: this.minPerformance,
                maxPerformance: this.maxPerformance,
                duration: this.elapsedTime,
                complexity: this.complexity,
                performanceData: this.performanceHistory
            };

            updateDistributionChart(this.performanceHistory);
        }

        updateUIStats(currentPerformance) {
            document.getElementById('fps').textContent = Math.round(currentPerformance);
            document.getElementById('duration').textContent = formatTime(this.elapsedTime);
            document.getElementById('test-progress').style.width = `${(this.elapsedTime / this.testDuration) * 100}%`;
            document.getElementById('test-progress').nextElementSibling.textContent = `${Math.round((this.elapsedTime / this.testDuration) * 100)}%`;

            const tempBase = 40 + (10 - currentPerformance / 10) + (this.complexity * 2);
            const tempRandom = Math.random() * 5;
            const temperature = Math.min(95, Math.max(40, tempBase + tempRandom));
            document.getElementById('temperature').textContent = `${Math.round(temperature)}°C`;

            const load = Math.min(99, Math.max(50, 70 + (this.complexity * 3) - (currentPerformance / 5)));
            document.getElementById('load').textContent = `${Math.round(load)}%`;
        }

        saveResults() {
            if (this.testResults) {
                saveTestResults(this.testResults);
            }
        }
    }

    class GPUTest extends BaseTest {
        constructor(renderApi = 'webgl1') {
            super();
            this.renderApi = renderApi;
            this.canvas = document.getElementById('glCanvas');
            this.particleCount = 100000;
            this.resolution = 1.0;
            this.antialiasing = 'none';
            this.disableCache = false;

            this.gl = null;
            this.initializeContext();

            if (!this.gl) {
                logToConsole(`Failed to initialize ${renderApi} context`, 'error');
                return;
            }

            this.setupShaders();

            if (this.shaderProgram && this.programInfo) {
                this.setupBuffers();
                this.resize();
                this.detectGPU();

                window.addEventListener('resize', () => this.resize());

                logToConsole(`GPU test initialized with ${this.renderApi} context`, 'info');
            } else {
                logToConsole(`Failed to initialize shaders for ${this.renderApi}`, 'error');
            }
        }

        initializeContext() {
            try {
                const antialiasing = document.getElementById('antialiasing').value;
                let antialiasSamples = 0;

                if (antialiasing === 'msaa2x') antialiasSamples = 2;
                else if (antialiasing === 'msaa4x') antialiasSamples = 4;
                else if (antialiasing === 'msaa8x') antialiasSamples = 8;

                this.antialiasing = antialiasing;

                const contextOptions = {
                    antialias: antialiasSamples > 0,
                    depth: true,
                    alpha: true,
                    powerPreference: 'high-performance'
                };

                if (antialiasSamples > 0) {
                    contextOptions.antialiasSamples = antialiasSamples;
                }

                switch(this.renderApi) {
                    case 'webgl1':
                        this.gl = this.canvas.getContext('webgl', contextOptions);
                        break;
                    case 'webgl2':
                        this.gl = this.canvas.getContext('webgl2', contextOptions);
                        if (!this.gl) {
                            logToConsole('WebGL 2 not supported, falling back to WebGL 1', 'warn');
                            this.gl = this.canvas.getContext('webgl', contextOptions);
                            this.renderApi = 'webgl1';
                        }
                        break;
                    case 'webgpu':
                        logToConsole('WebGPU currently not implemented, using WebGL instead', 'warn');
                        this.gl = this.canvas.getContext('webgl2', contextOptions);
                        if (this.gl) {
                            this.renderApi = 'webgl2';
                        } else {
                            this.gl = this.canvas.getContext('webgl', contextOptions);
                            this.renderApi = 'webgl1';
                        }
                        break;
                }

                if (!this.gl) {
                    logToConsole('WebGL is not supported in this browser', 'error');
                } else {
                    logToConsole(`Initialized with antialiasing: ${this.antialiasing}`, 'info');

                    const antialias = this.gl.getContextAttributes().antialias;
                    logToConsole(`Antialiasing enabled: ${antialias ? 'Yes' : 'No'}`, 'info');
                }
            } catch (e) {
                logToConsole(`Error initializing context: ${e.message}`, 'error');
                this.gl = null;
            }
        }

        detectGPU() {
            if (!this.gl) {
                document.getElementById('hardware-info').textContent = 'WebGL not supported';
                return;
            }

            const debugInfo = this.gl.getExtension('WEBGL_debug_renderer_info');
            if (debugInfo) {
                const renderer = this.gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                document.getElementById('hardware-info').textContent = renderer;
                logToConsole(`Detected GPU: ${renderer}`, 'info');
            } else {
                document.getElementById('hardware-info').textContent = 'GPU info not available';
                logToConsole('Could not detect GPU info - WEBGL_debug_renderer_info extension not available', 'warn');
            }
        }

        setupShaders() {
            if (!this.gl) return;

            try {
                const vsSource = `
            precision mediump float;
            
            attribute vec4 aVertexPosition;
            attribute vec4 aVertexColor;
            
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform float uTime;
            uniform float uComplexity;
            
            varying vec4 vColor;
            
            void main(void) {
                // Apply time-based transformation
                float offset = sin(uTime * 0.001 * uComplexity) * 0.5;
                vec4 position = aVertexPosition;
                position.x += offset * position.y;
                position.y += cos(uTime * 0.0015 * uComplexity) * 0.3;
                
                gl_Position = uProjectionMatrix * uModelViewMatrix * position;
                gl_PointSize = 2.0;
                vColor = aVertexColor;
            }
        `;

                const fsSource = `
    precision mediump float;
    
    varying vec4 vColor;
    
    uniform float uTime;
    uniform float uComplexity;
    
    void main(void) {
        // Make colors pulsate with time
        float t = abs(sin(uTime * 0.001));
        vec4 color = vColor;
        
        // Create complex iterative calculations that scale with complexity
        for (int i = 0; i < 20; i++) {
            if (float(i) < uComplexity * 2.0) {
                // More expensive calculations with trig functions
                vec3 complex = vec3(
                    sin(color.r * 5.0 * 3.14159 + uTime * 0.0007),
                    cos(color.g * 7.0 * 3.14159 + uTime * 0.0009),
                    tan(color.b * 3.0 * 3.14159 + uTime * 0.0005)
                );
                
                // Add complexity with more calculations
                complex = normalize(complex) * pow(length(complex), uComplexity * 0.1);
                
                // Mix with original color
                color.rgb = mix(color.rgb, complex, 0.1);
                
                // Add more expensive operations
                color.r = mix(color.r, sin(color.g * color.b * uTime * 0.0001), 0.05);
                color.g = mix(color.g, cos(color.r * color.b * uTime * 0.0002), 0.05);
                color.b = mix(color.b, sin(color.r * color.g * uTime * 0.0003), 0.05);
            }
        }
        
        gl_FragColor = color;
    }
`;
                const vertexShader = this.loadShader(this.gl.VERTEX_SHADER, vsSource);
                if (!vertexShader) {
                    logToConsole('Failed to compile vertex shader', 'error');
                    return;
                }

                const fragmentShader = this.loadShader(this.gl.FRAGMENT_SHADER, fsSource);
                if (!fragmentShader) {
                    logToConsole('Failed to compile fragment shader', 'error');
                    return;
                }

                this.shaderProgram = this.gl.createProgram();
                this.gl.attachShader(this.shaderProgram, vertexShader);
                this.gl.attachShader(this.shaderProgram, fragmentShader);
                this.gl.linkProgram(this.shaderProgram);

                if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
                    const info = this.gl.getProgramInfoLog(this.shaderProgram);
                    logToConsole(`Unable to initialize the shader program: ${info}`, 'error');
                    this.shaderProgram = null;
                    return;
                }

                this.programInfo = {
                    program: this.shaderProgram,
                    attribLocations: {
                        vertexPosition: this.gl.getAttribLocation(this.shaderProgram, 'aVertexPosition'),
                        vertexColor: this.gl.getAttribLocation(this.shaderProgram, 'aVertexColor'),
                    },
                    uniformLocations: {
                        projectionMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uProjectionMatrix'),
                        modelViewMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uModelViewMatrix'),
                        time: this.gl.getUniformLocation(this.shaderProgram, 'uTime'),
                        complexity: this.gl.getUniformLocation(this.shaderProgram, 'uComplexity'),
                    },
                };

                logToConsole('Shader program initialized successfully', 'info');
            } catch (e) {
                logToConsole(`Error initializing shaders: ${e.message}`, 'error');
                this.shaderProgram = null;
                this.programInfo = null;
            }
        }

        loadShader(type, source) {
            const shader = this.gl.createShader(type);
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);

            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                const info = this.gl.getShaderInfoLog(shader);
                logToConsole(`An error occurred compiling the shaders: ${info}`, 'error');
                this.gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        setupBuffers() {
            if (!this.gl) return;

            try {
                this.regenerateBuffers();
            } catch (e) {
                logToConsole(`Error setting up buffers: ${e.message}`, 'error');
            }
        }

        regenerateBuffers() {
            if (!this.gl) return;

            try {
                const positions = [];
                const colors = [];

                for (let i = 0; i < this.particleCount; i++) {
                    positions.push(
                        (Math.random() * 2 - 1),
                        (Math.random() * 2 - 1),
                        (Math.random() * 2 - 1)
                    );

                    colors.push(
                        Math.random(),
                        Math.random(),
                        Math.random(),
                        1.0
                    );
                }

                this.positionBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);

                this.colorBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);

                logToConsole(`Generated buffers with ${this.particleCount} particles`, 'info');
            } catch (e) {
                logToConsole(`Error creating buffers: ${e.message}`, 'error');
            }
        }

        resize() {
            if (!this.gl) return;

            try {
                const devicePixelRatio = window.devicePixelRatio || 1;

                const displayWidth = this.canvas.clientWidth;
                const displayHeight = this.canvas.clientHeight;

                const width = Math.floor(displayWidth * devicePixelRatio * this.resolution);
                const height = Math.floor(displayHeight * devicePixelRatio * this.resolution);

                if (this.canvas.width !== width || this.canvas.height !== height) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                    this.gl.viewport(0, 0, width, height);
                    logToConsole(`Canvas resized to ${width}x${height} (${this.resolution}x resolution)`, 'info');
                }
            } catch (e) {
                logToConsole(`Error resizing canvas: ${e.message}`, 'error');
            }
        }

        start() {
            if (!this.gl || !this.shaderProgram || !this.programInfo) {
                logToConsole('Cannot start test - WebGL context or shader program not initialized', 'error');
                alert('GPU test initialization failed. Please try a different API or refresh the page.');
                return;
            }
            this.detectGPU();
            if (this.canvas.requestPointerLock) {
                try {
                    this.canvas.requestPointerLock();
                    setTimeout(() => {
                        if (document.exitPointerLock) {
                            document.exitPointerLock();
                        }
                    }, 100);
                    logToConsole('Attempting to disable FPS limiting', 'info');
                } catch (e) {
                }
            }

            super.start();

            this.particleCount = parseInt(document.getElementById('particleCount').value);
            this.resolution = parseFloat(document.getElementById('resolution').value);

            this.regenerateBuffers();
            this.resize();

            this.lastFrameTime = performance.now();
            requestAnimationFrame(this.render.bind(this));

            this.testResults = {
                mode: 'gpu',
                renderApi: this.renderApi,
                hardware: document.getElementById('hardware-info').textContent,
                antialiasing: this.antialiasing,
                particleCount: this.particleCount,
                resolution: this.resolution
            };

            logToConsole(`Starting GPU test with ${this.renderApi}`, 'info');
        }

        render(now) {
            if (!this.running || !this.gl || !this.programInfo) return;

            const deltaTime = now - this.lastFrameTime;
            this.lastFrameTime = now;

            const renderPasses = Math.max(1, Math.floor(this.complexity * 2));

            for (let pass = 0; pass < renderPasses; pass++) {
                try {
                    if (pass === 0) {
                        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
                        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                    }

                    const fieldOfView = 45 * Math.PI / 180;
                    const aspect = this.gl.canvas.clientWidth / this.gl.canvas.clientHeight || 1;
                    const zNear = 0.1;
                    const zFar = 100.0;
                    const projectionMatrix = mat4.create();

                    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

                    const modelViewMatrix = mat4.create();
                    const passOffset = pass * 0.01;
                    mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -6.0]);
                    mat4.rotate(modelViewMatrix, modelViewMatrix, now * 0.001 + passOffset, [0, 1, 0]);
                    mat4.rotate(modelViewMatrix, modelViewMatrix, now * 0.0005 + passOffset, [1, 0, 0]);

                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                    this.gl.vertexAttribPointer(
                        this.programInfo.attribLocations.vertexPosition,
                        3, this.gl.FLOAT, false, 0, 0
                    );
                    this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);

                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
                    this.gl.vertexAttribPointer(
                        this.programInfo.attribLocations.vertexColor,
                        4, this.gl.FLOAT, false, 0, 0
                    );
                    this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexColor);

                    this.gl.useProgram(this.programInfo.program);

                    this.gl.uniformMatrix4fv(
                        this.programInfo.uniformLocations.projectionMatrix,
                        false, projectionMatrix
                    );
                    this.gl.uniformMatrix4fv(
                        this.programInfo.uniformLocations.modelViewMatrix,
                        false, modelViewMatrix
                    );
                    this.gl.uniform1f(
                        this.programInfo.uniformLocations.time,
                        now + pass * 100
                    );
                    this.gl.uniform1f(
                        this.programInfo.uniformLocations.complexity,
                        this.complexity
                    );

                    this.gl.drawArrays(this.gl.POINTS, 0, this.particleCount);
                } catch (e) {
                    logToConsole(`Render error: ${e.message}`, 'error');
                    this.stop();
                }
            }

            if (deltaTime > 0) {
                const currentFps = 1000 / deltaTime;
                this.fps = currentFps;

                this.totalPerformance += currentFps;
                this.performanceReadings++;
                this.minPerformance = Math.min(this.minPerformance, currentFps);
                this.maxPerformance = Math.max(this.maxPerformance, currentFps);

                const secondsElapsed = (now - this.startTime) / 1000;
                if (this.performanceHistory.length === 0 ||
                    secondsElapsed - this.performanceHistory[this.performanceHistory.length - 1].time >= 0.5) {
                    this.performanceHistory.push({
                        time: secondsElapsed,
                        performance: currentFps,
                        metric: 'FPS'
                    });

                    updatePerformanceChart(this.performanceHistory);
                }

                this.updateUIStats(currentFps);
            }

            this.elapsedTime = Math.floor((now - this.startTime) / 1000);

            if (this.elapsedTime >= this.testDuration) {
                this.stop();
                return;
            }

            requestAnimationFrame(this.render.bind(this));
        }
        stop() {
            super.stop();

            if (this.testResults) {
                this.testResults.particleCount = this.particleCount;
                this.testResults.resolution = this.resolution;
            }

            logToConsole('GPU test completed', 'info');
        }
    }

    class CPUSingleThreadTest extends BaseTest {
        constructor() {
            super();
            this.canvas = document.getElementById('cpuCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.iterationCount = 1000;
            this.particles = [];

            this.detectCPU();
            this.resize();

            window.addEventListener('resize', () => this.resize());

            logToConsole('CPU single thread test initialized', 'info');
        }

        detectCPU() {
            const cpuInfo = `CPU (${navigator.hardwareConcurrency || 'Unknown'} logical cores)`;
            document.getElementById('hardware-info').textContent = cpuInfo;
            logToConsole(`Detected ${cpuInfo}`, 'info');
        }

        resize() {
            const width = this.canvas.clientWidth;
            const height = this.canvas.clientHeight;

            if (this.canvas.width !== width || this.canvas.height !== height) {
                this.canvas.width = width;
                this.canvas.height = height;
            }
        }

        initParticles() {
            this.particles = [];
            const particleCount = 1000;

            for (let i = 0; i < particleCount; i++) {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    radius: Math.random() * 3 + 1,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * 2 - 1
                });
            }
        }

        drawParticles(time) {
            if (!this.ctx) return;

            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            const angleOffset = time * 0.001 * this.complexity;

            for (let i = 0; i < this.particles.length; i++) {
                const p = this.particles[i];

                p.x += p.vx + Math.sin(angleOffset + i * 0.1) * 0.5;
                p.y += p.vy + Math.cos(angleOffset + i * 0.1) * 0.5;

                if (p.x < 0) p.x = this.canvas.width;
                if (p.x > this.canvas.width) p.x = 0;
                if (p.y < 0) p.y = this.canvas.height;
                if (p.y > this.canvas.height) p.y = 0;

                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = p.color;
                this.ctx.fill();
            }
        }

        performCPUWork() {
            const startTime = performance.now();

            let result = 0;
            for (let i = 0; i < this.iterationCount; i++) {
                const size = 10 * this.complexity;
                const matrix = [];

                const cacheBreakerOffset = this.disableCache ? Math.sin(this.cacheBreaker + i * 0.01) : 0;

                for (let x = 0; x < size; x++) {
                    matrix[x] = [];
                    for (let y = 0; y < size; y++) {
                        matrix[x][y] = Math.sin(x * y + cacheBreakerOffset) * Math.cos(x + y + cacheBreakerOffset);
                    }
                }

                for (let x = 0; x < size; x++) {
                    for (let y = 0; y < size; y++) {
                        result += Math.sqrt(Math.pow(matrix[x][y], 2));
                    }
                }
            }

            const endTime = performance.now();
            const duration = endTime - startTime;

            return 1000 / duration;
        }

        start() {


            super.start();

            document.getElementById('fps-label').textContent = 'OPS:';

            this.iterationCount = parseInt(document.getElementById('iterationCount').value);
            this.disableCache = document.getElementById('disable-cache').checked;

            if (this.disableCache) {
                logToConsole('Cache disabled: Using non-cached calculations', 'info');
                this.cacheBreaker = Math.random();
            }

            this.initParticles();

            this.lastFrameTime = performance.now();
            requestAnimationFrame(this.update.bind(this));

            this.testResults = {
                mode: 'cpu-single',
                disableCache: this.disableCache,
                hardware: document.getElementById('hardware-info').textContent
            };

            logToConsole(`Starting CPU single thread test with ${this.iterationCount} iterations (Cache Disabled: ${this.disableCache ? 'Yes' : 'No'})`, 'info');
        }

        update(now) {
            if (!this.running) return;

            this.elapsedTime = Math.floor((now - this.startTime) / 1000);

            try {
                const performanceValue = this.performCPUWork();

                this.totalPerformance += performanceValue;
                this.performanceReadings++;
                this.minPerformance = Math.min(this.minPerformance, performanceValue);
                this.maxPerformance = Math.max(this.maxPerformance, performanceValue);

                const secondsElapsed = (now - this.startTime) / 1000;
                if (this.performanceHistory.length === 0 ||
                    secondsElapsed - this.performanceHistory[this.performanceHistory.length - 1].time >= 0.5) {
                    this.performanceHistory.push({
                        time: secondsElapsed,
                        performance: performanceValue,
                        metric: 'OPS'
                    });

                    updatePerformanceChart(this.performanceHistory);
                }

                this.drawParticles(now);

                this.updateUIStats(performanceValue);
            } catch (e) {
                logToConsole(`CPU test error: ${e.message}`, 'error');
            }

            if (this.elapsedTime >= this.testDuration) {
                this.stop();
                return;
            }

            requestAnimationFrame(this.update.bind(this));
        }

        stop() {
            super.stop();

            if (this.testResults) {
                this.testResults.iterationCount = this.iterationCount;
            }

            document.getElementById('fps-label').textContent = 'FPS:';

            logToConsole('CPU single thread test completed', 'info');
        }
    }

    class CPUMultiThreadTest extends BaseTest {
        constructor() {
            super();
            this.canvas = document.getElementById('cpuCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.iterationCount = 1000;
            this.particles = [];
            this.workers = [];
            this.threadCount = 4;
            this.pendingWorkers = 0;

            this.detectCPU();
            this.resize();

            window.addEventListener('resize', () => this.resize());

            logToConsole('CPU multi-thread test initialized', 'info');
        }

        detectCPU() {
            const cpuInfo = `CPU (${navigator.hardwareConcurrency || 'Unknown'} logical cores)`;
            document.getElementById('hardware-info').textContent = cpuInfo;
            logToConsole(`Detected ${cpuInfo}`, 'info');

            if (document.getElementById('thread-count').value === 'auto') {
                this.threadCount = navigator.hardwareConcurrency || 4;
            } else {
                this.threadCount = parseInt(document.getElementById('thread-count').value);
            }
        }

        resize() {
            const width = this.canvas.clientWidth;
            const height = this.canvas.clientHeight;

            if (this.canvas.width !== width || this.canvas.height !== height) {
                this.canvas.width = width;
                this.canvas.height = height;
            }
        }

        initParticles() {
            this.particles = [];
            const particleCount = 1000;

            for (let i = 0; i < particleCount; i++) {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    radius: Math.random() * 3 + 1,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * 2 - 1
                });
            }
        }

        drawParticles(time) {
            if (!this.ctx) return;

            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            const angleOffset = time * 0.001 * this.complexity;

            for (let i = 0; i < this.particles.length; i++) {
                const p = this.particles[i];

                p.x += p.vx + Math.sin(angleOffset + i * 0.1) * 0.5;
                p.y += p.vy + Math.cos(angleOffset + i * 0.1) * 0.5;

                if (p.x < 0) p.x = this.canvas.width;
                if (p.x > this.canvas.width) p.x = 0;
                if (p.y < 0) p.y = this.canvas.height;
                if (p.y > this.canvas.height) p.y = 0;

                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = p.color;
                this.ctx.fill();
            }
        }

        createWorkers() {
            this.workers = [];
            this.pendingWorkers = this.threadCount;

            try {
                for (let i = 0; i < this.threadCount; i++) {
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const workerUrl = URL.createObjectURL(blob);

                    const worker = new Worker(workerUrl);

                    worker.onmessage = (e) => {
                        const { id, result, duration } = e.data;
                        this.pendingWorkers--;

                        const ops = 1000 / duration;

                        this.workerPerformance[id] = ops;

                        if (this.pendingWorkers === 0) {
                            this.calculateAveragePerformance();
                        }
                    };

                    worker.onerror = (e) => {
                        logToConsole(`Worker error: ${e.message}`, 'error');
                        this.pendingWorkers--;
                    };

                    this.workers.push({
                        worker: worker,
                        id: i
                    });
                }

                logToConsole(`Created ${this.threadCount} worker threads`, 'info');
            } catch (e) {
                logToConsole(`Error creating workers: ${e.message}`, 'error');
            }
        }

        runWorkersIteration() {
            if (this.workers.length === 0) return;

            this.pendingWorkers = this.threadCount;
            this.workerPerformance = {};

            const iterationsPerWorker = Math.floor(this.iterationCount / this.threadCount);

            try {
                this.workers.forEach(({ worker, id }) => {
                    worker.postMessage({
                        id: id,
                        iterationCount: iterationsPerWorker,
                        complexity: this.complexity
                    });
                });
            } catch (e) {
                logToConsole(`Error running workers: ${e.message}`, 'error');
            }
        }

        calculateAveragePerformance() {
            let totalPerformance = 0;
            let workerCount = 0;

            for (const id in this.workerPerformance) {
                totalPerformance += this.workerPerformance[id];
                workerCount++;
            }

            if (workerCount === 0) return;

            const averagePerformance = totalPerformance / workerCount;

            this.currentPerformance = averagePerformance;
            this.totalPerformance += averagePerformance;
            this.performanceReadings++;
            this.minPerformance = Math.min(this.minPerformance, averagePerformance);
            this.maxPerformance = Math.max(this.maxPerformance, averagePerformance);

            const secondsElapsed = (performance.now() - this.startTime) / 1000;
            if (this.performanceHistory.length === 0 ||
                secondsElapsed - this.performanceHistory[this.performanceHistory.length - 1].time >= 0.5) {
                this.performanceHistory.push({
                    time: secondsElapsed,
                    performance: averagePerformance,
                    metric: 'OPS'
                });

                updatePerformanceChart(this.performanceHistory);
            }

            this.updateUIStats(averagePerformance);
        }

        start() {


            super.start();

            document.getElementById('fps-label').textContent = 'OPS:';

            this.iterationCount = parseInt(document.getElementById('iterationCount').value);
            this.threadCount = document.getElementById('thread-count').value === 'auto'
                ? (navigator.hardwareConcurrency || 4)
                : parseInt(document.getElementById('thread-count').value);

            this.initParticles();
            this.createWorkers();
            this.currentPerformance = 0;

            this.lastFrameTime = performance.now();
            this.workerPerformance = {};

            this.runWorkersIteration();

            requestAnimationFrame(this.update.bind(this));

            this.testResults = {
                mode: 'cpu-multi',
                threadCount: this.threadCount,
                hardware: document.getElementById('hardware-info').textContent
            };

            logToConsole(`Starting CPU multi-thread test with ${this.threadCount} threads and ${this.iterationCount} iterations`, 'info');
        }

        update(now) {
            if (!this.running) return;

            this.elapsedTime = Math.floor((now - this.startTime) / 1000);

            this.drawParticles(now);

            if (this.pendingWorkers === 0 && this.running) {
                this.runWorkersIteration();
            }

            if (this.elapsedTime >= this.testDuration) {
                this.stop();
                return;
            }

            requestAnimationFrame(this.update.bind(this));
        }

        stop() {
            super.stop();

            try {
                this.workers.forEach(({ worker }) => {
                    worker.terminate();
                });
            } catch (e) {
                logToConsole(`Error terminating workers: ${e.message}`, 'error');
            }

            this.workers = [];

            if (this.testResults) {
                this.testResults.iterationCount = this.iterationCount;
            }

            document.getElementById('fps-label').textContent = 'FPS:';

            logToConsole('CPU multi-thread test completed', 'info');
        }
    }

    const mat4 = {
        create: function() {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        },

        perspective: function(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);

            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = (2 * far * near) * nf;
            out[15] = 0;

            return out;
        },

        translate: function(out, a, v) {
            const x = v[0], y = v[1], z = v[2];

            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];

            return out;
        },

        rotate: function(out, a, rad, axis) {
            let x = axis[0], y = axis[1], z = axis[2];
            let len = Math.sqrt(x * x + y * y + z * z);

            if (len < 0.000001) {
                return a;
            }

            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;

            const s = Math.sin(rad);
            const c = Math.cos(rad);
            const t = 1 - c;

            const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];

            const b00 = x * x * t + c;
            const b01 = y * x * t + z * s;
            const b02 = z * x * t - y * s;
            const b10 = x * y * t - z * s;
            const b11 = y * y * t + c;
            const b12 = z * y * t + x * s;
            const b20 = x * z * t + y * s;
            const b21 = y * z * t - x * s;
            const b22 = z * z * t + c;

            out[0] = a00 * b00 + a10 * b01 + a20 * b02;
            out[1] = a01 * b00 + a11 * b01 + a21 * b02;
            out[2] = a02 * b00 + a12 * b01 + a22 * b02;
            out[3] = a03 * b00 + a13 * b01 + a23 * b02;
            out[4] = a00 * b10 + a10 * b11 + a20 * b12;
            out[5] = a01 * b10 + a11 * b11 + a21 * b12;
            out[6] = a02 * b10 + a12 * b11 + a22 * b12;
            out[7] = a03 * b10 + a13 * b11 + a23 * b12;
            out[8] = a00 * b20 + a10 * b21 + a20 * b22;
            out[9] = a01 * b20 + a11 * b21 + a21 * b22;
            out[10] = a02 * b20 + a12 * b21 + a22 * b22;
            out[11] = a03 * b20 + a13 * b21 + a23 * b22;

            if (a !== out) {
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            return out;
        }
    };

    let performanceChart = null;
    let distributionChart = null;
    let historyChart = null;

    function setupCharts() {
        const perfCtx = document.getElementById('performanceChart').getContext('2d');
        performanceChart = new Chart(perfCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Performance',
                    data: [],
                    borderColor: '#4a6cf7',
                    backgroundColor: 'rgba(74, 108, 247, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (seconds)'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Performance'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const metric = context.dataset.metric || 'Performance';
                                return `${metric}: ${context.parsed.y.toFixed(1)}`;
                            }
                        }
                    }
                }
            }
        });

        const distCtx = document.getElementById('distributionChart').getContext('2d');
        distributionChart = new Chart(distCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Performance Distribution',
                    data: [],
                    backgroundColor: 'rgba(74, 108, 247, 0.7)',
                    borderColor: '#4a6cf7',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Range'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Frequency'
                        }
                    }
                }
            }
        });

        const histCtx = document.getElementById('historyChart').getContext('2d');
        historyChart = new Chart(histCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Score',
                    data: [],
                    backgroundColor: 'rgba(74, 108, 247, 0.7)',
                    borderColor: '#4a6cf7',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Date'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Score'
                        }
                    }
                }
            }
        });
    }

    function updatePerformanceChart(performanceData) {
        if (!performanceChart || performanceData.length === 0) return;

        try {
            const metric = performanceData[0].metric || 'Performance';

            performanceChart.data.datasets[0].data = performanceData.map(point => ({
                x: point.time,
                y: point.performance
            }));

            performanceChart.data.datasets[0].metric = metric;
            performanceChart.options.scales.y.title.text = metric;

            performanceChart.update();
        } catch (e) {
            logToConsole(`Error updating performance chart: ${e.message}`, 'error');
        }
    }

    function updateDistributionChart(performanceData) {
        if (!distributionChart || performanceData.length === 0) return;

        try {
            const bucketSize = 10;
            const buckets = {};
            const min = Math.floor(Math.min(...performanceData.map(d => d.performance)) / bucketSize) * bucketSize;
            const max = Math.ceil(Math.max(...performanceData.map(d => d.performance)) / bucketSize) * bucketSize;

            for (let i = min; i <= max; i += bucketSize) {
                buckets[i] = 0;
            }

            performanceData.forEach(data => {
                const bucketKey = Math.floor(data.performance / bucketSize) * bucketSize;
                if (buckets[bucketKey] !== undefined) {
                    buckets[bucketKey]++;
                }
            });

            distributionChart.data.labels = Object.keys(buckets).map(key => `${key}-${parseInt(key) + bucketSize}`);
            distributionChart.data.datasets[0].data = Object.values(buckets);

            const metric = performanceData[0].metric || 'Performance';
            distributionChart.data.datasets[0].label = `${metric} Distribution`;

            distributionChart.update();
        } catch (e) {
            logToConsole(`Error updating distribution chart: ${e.message}`, 'error');
        }
    }

    function updateHistoryView() {
        const data = getAllTestResults();
        const days = Object.keys(data).sort();

        if (days.length === 0) {
            historyChart.data.labels = [];
            historyChart.data.datasets[0].data = [];
            historyChart.update();
            return;
        }

        try {
            const dailyScores = days.map(day => {
                const tests = data[day];
                if (!tests || tests.length === 0) return 0;

                const total = tests.reduce((sum, test) => sum + (test.score || 0), 0);
                return Math.round(total / tests.length);
            });

            historyChart.data.labels = days;
            historyChart.data.datasets[0].data = dailyScores;
            historyChart.update();

            const tableBody = document.getElementById('history-table-body');
            tableBody.innerHTML = '';

            if (days.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No data available</td></tr>';
                return;
            }

            days.forEach(day => {
                const tests = data[day];
                if (!tests || tests.length === 0) return;

                tests.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                tests.forEach(test => {
                    const row = document.createElement('tr');

                    const timeStr = new Date(test.timestamp).toLocaleTimeString();

                    let modeText = 'GPU';
                    if (test.mode === 'cpu-single') {
                        modeText = 'CPU (Single Thread)';
                    } else if (test.mode === 'cpu-multi') {
                        modeText = `CPU (${test.threadCount} Threads)`;
                    } else if (test.renderApi) {
                        modeText = `GPU (${test.renderApi})`;
                    }

                    row.innerHTML = `
                            <td>${day} ${timeStr}</td>
                            <td>${modeText}</td>
                            <td>${formatNumber(test.score || 0)}</td>
                            <td>${(test.avgPerformance || 0).toFixed(1)} ${test.performanceData?.[0]?.metric || 'FPS'}</td>
                            <td>${formatTime(test.duration || 0)}</td>
                            <td>
                                <button class="btn btn-sm" data-test-id="${test.id}" style="padding: 5px 10px; font-size: 0.8rem;">
                                    View Details
                                </button>
                            </td>
                        `;

                    tableBody.appendChild(row);
                });
            });

            document.querySelectorAll('[data-test-id]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const testId = parseInt(btn.getAttribute('data-test-id'));
                    viewTestDetails(testId);
                });
            });
        } catch (e) {
            logToConsole(`Error updating history view: ${e.message}`, 'error');
        }
    }

    function viewTestDetails(testId) {
        const data = getAllTestResults();
        let test = null;

        for (const day in data) {
            const found = data[day].find(t => t.id === testId);
            if (found) {
                test = found;
                break;
            }
        }

        if (!test) {
            alert('Test details not found');
            return;
        }

        try {
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '999';

            const modalContent = document.createElement('div');
            modalContent.style.backgroundColor = 'var(--card-bg)';
            modalContent.style.borderRadius = '12px';
            modalContent.style.padding = '25px';
            modalContent.style.width = '80%';
            modalContent.style.maxWidth = '800px';
            modalContent.style.maxHeight = '80%';
            modalContent.style.overflow = 'auto';
            modalContent.style.boxShadow = '0 12px 24px rgba(0, 0, 0, 0.2)';

            let modeText = 'GPU';
            if (test.mode === 'cpu-single') {
                modeText = 'CPU (Single Thread)';
            } else if (test.mode === 'cpu-multi') {
                modeText = `CPU (${test.threadCount} Threads)`;
            } else if (test.renderApi) {
                modeText = `GPU (${test.renderApi})`;
            }

            const metricName = test.performanceData?.[0]?.metric || 'FPS';

            modalContent.innerHTML = `
                    <h2 style="color: var(--primary); margin-bottom: 20px;">Test Details</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
                        <div>
                            <p><strong>Date:</strong> ${new Date(test.timestamp).toLocaleString()}</p>
                            <p><strong>Mode:</strong> ${modeText}</p>
                            <p><strong>Score:</strong> ${formatNumber(test.score || 0)}</p>
                            <p><strong>Avg ${metricName}:</strong> ${(test.avgPerformance || 0).toFixed(1)}</p>
                            <p><strong>Min ${metricName}:</strong> ${(test.minPerformance || 0).toFixed(1)}</p>
                            <p><strong>Max ${metricName}:</strong> ${(test.maxPerformance || 0).toFixed(1)}</p>
                        </div>
                        <div>
                            <p><strong>Duration:</strong> ${formatTime(test.duration || 0)}</p>
                            <p><strong>Complexity:</strong> ${test.complexity || 'N/A'}</p>
                            ${test.particleCount ? `<p><strong>Particles:</strong> ${formatNumber(test.particleCount)}</p>` : ''}
                            ${test.resolution ? `<p><strong>Resolution:</strong> ${test.resolution}x</p>` : ''}
                            ${test.iterationCount ? `<p><strong>Iterations:</strong> ${formatNumber(test.iterationCount)}</p>` : ''}
                            <p><strong>Hardware:</strong> ${test.hardware || 'Unknown'}</p>
                        </div>
                    </div>
                    <div style="height: 300px; margin-bottom: 25px;">
                        <canvas id="detailChart"></canvas>
                    </div>
                    <button id="closeModal" class="btn" style="margin-top: 15px;">Close</button>
                `;

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            if (test.performanceData && test.performanceData.length > 0) {
                const ctx = document.getElementById('detailChart').getContext('2d');
                const detailChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: metricName,
                            data: test.performanceData.map(point => ({
                                x: point.time,
                                y: point.performance
                            })),
                            borderColor: '#4a6cf7',
                            backgroundColor: 'rgba(74, 108, 247, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'Time (seconds)'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: metricName
                                }
                            }
                        }
                    }
                });
            }

            document.getElementById('closeModal').addEventListener('click', () => {
                document.body.removeChild(modal);
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        } catch (e) {
            logToConsole(`Error displaying test details: ${e.message}`, 'error');
        }
    }

    function applyTheme(theme) {
        if (theme === 'dark' || (theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }
    }

    function setupThemeHandling() {
        const themeSelect = document.getElementById('theme');

        const savedTheme = localStorage.getItem('stressTestTheme') || 'light';
        themeSelect.value = savedTheme;
        applyTheme(savedTheme);

        themeSelect.addEventListener('change', () => {
            const theme = themeSelect.value;
            localStorage.setItem('stressTestTheme', theme);
            applyTheme(theme);
        });

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            if (themeSelect.value === 'auto') {
                applyTheme('auto');
            }
        });
    }

    function setupTestModeHandling() {
        const radioButtons = document.querySelectorAll('input[name="test-mode"]');

        const initialMode = document.querySelector('input[name="test-mode"]:checked').value;
        updateUIForMode(initialMode);

        radioButtons.forEach(radio => {
            radio.addEventListener('change', () => {
                const mode = radio.value;
                updateUIForMode(mode);
                logToConsole(`Test mode changed to ${mode}`, 'info');
            });
        });

        function updateUIForMode(mode) {
            document.getElementById('gpu-options').style.display = 'none';
            document.getElementById('cpu-options').style.display = 'none';
            document.getElementById('memory-options').style.display = 'none';
            document.getElementById('network-options').style.display = 'none';
            document.getElementById('thread-count-container').style.display = 'none';
            document.getElementById('particle-setting').style.display = 'none';
            document.getElementById('resolution-setting').style.display = 'none';
            document.getElementById('iteration-setting').style.display = 'none';
            document.getElementById('antialiasing-setting').style.display = 'none';
            document.getElementById('network-test-container').style.display = 'none';

            if (mode === 'cpu-multi') {
                document.getElementById('cpu-options').style.display = 'block';
                document.getElementById('thread-count-container').style.display = 'block';
                document.getElementById('iteration-setting').style.display = 'block';

                document.getElementById('glCanvas').style.display = 'none';
                document.getElementById('cpuCanvas').style.display = 'block';
            } else if (mode === 'cpu-single') {
                document.getElementById('cpu-options').style.display = 'block';
                document.getElementById('iteration-setting').style.display = 'block';
                document.getElementById('thread-count-container').style.display = 'none';

                document.getElementById('glCanvas').style.display = 'none';
                document.getElementById('cpuCanvas').style.display = 'block';
            } else if (mode === 'memory') {
                document.getElementById('memory-options').style.display = 'block';

                document.getElementById('glCanvas').style.display = 'none';
                document.getElementById('cpuCanvas').style.display = 'block';
            } else if (mode === 'network') {
                document.getElementById('network-options').style.display = 'block';
                document.getElementById('network-test-container').style.display = 'block';

                document.getElementById('glCanvas').style.display = 'none';
                document.getElementById('cpuCanvas').style.display = 'none';
            } else {
                document.getElementById('gpu-options').style.display = 'block';
                document.getElementById('particle-setting').style.display = 'block';
                document.getElementById('resolution-setting').style.display = 'block';
                document.getElementById('antialiasing-setting').style.display = 'block';

                document.getElementById('glCanvas').style.display = 'block';
                document.getElementById('cpuCanvas').style.display = 'none';
            }
        }
    }

    function createTestInstance() {
        try {
            const mode = document.querySelector('input[name="test-mode"]:checked').value;

            if (mode === 'gpu') {
                const renderApi = document.getElementById('render-api').value;
                return new GPUTest(renderApi);
            } else if (mode === 'cpu-single') {
                return new CPUSingleThreadTest();
            } else if (mode === 'cpu-multi') {
                return new CPUMultiThreadTest();
            } else if (mode === 'memory') {
                return new MemoryTest();
            } else if (mode === 'network') {
                return new NetworkTest();
            }
        } catch (e) {
            logToConsole(`Error creating test instance: ${e.message}`, 'error');
            return null;
        }
    }

    function createRangeValueDisplay(rangeEl, suffix = '') {
        const valueDisplay = document.createElement('div');
        valueDisplay.className = 'range-current-value';
        valueDisplay.style.textAlign = 'center';
        valueDisplay.style.marginTop = '5px';
        valueDisplay.style.fontWeight = 'bold';
        valueDisplay.textContent = `${rangeEl.value}${suffix}`;

        rangeEl.parentNode.insertBefore(valueDisplay, rangeEl.nextElementSibling);

        rangeEl.addEventListener('input', function() {
            valueDisplay.textContent = `${this.value}${suffix}`;
        });

        return valueDisplay;
    }

    document.addEventListener('DOMContentLoaded', () => {
        try {
            setupTabs();
            setupCharts();
            setupThemeHandling();
            setupTestModeHandling();

            if (!window.navigator.gpu) {
                const webGpuOption = document.querySelector('option[value="webgpu"]');
                if (webGpuOption) {
                    webGpuOption.disabled = true;
                    webGpuOption.text = 'WebGPU (Not Supported)';
                }
                logToConsole('WebGPU is not supported in this browser', 'warn');
            }

            const cpuCores = navigator.hardwareConcurrency || 'unknown';
            logToConsole(`Detected ${cpuCores} logical CPU cores`, 'info');

            let currentTest = null;

            document.getElementById('start-btn').addEventListener('click', () => {
                document.getElementById('start-btn').disabled = true;

                currentTest = createTestInstance();
                if (currentTest) {
                    currentTest.start();
                } else {
                    logToConsole('Failed to initialize test', 'error');
                    document.getElementById('start-btn').disabled = false;
                }
            });

            document.getElementById('stop-btn').addEventListener('click', () => {
                if (currentTest) {
                    currentTest.stop();
                }
            });

            document.getElementById('save-btn').addEventListener('click', () => {
                if (currentTest) {
                    currentTest.saveResults();
                }
            });

            document.getElementById('clearData').addEventListener('click', clearAllData);
            document.getElementById('exportData').addEventListener('click', exportData);

            document.getElementById('render-api').addEventListener('change', function() {
                logToConsole(`Rendering API changed to ${this.value}`, 'info');
            });

            document.getElementById('thread-count').addEventListener('change', function() {
                const value = this.value;
                const displayValue = value === 'auto' ?
                    `Auto (${navigator.hardwareConcurrency || 4} cores)` :
                    `${value} threads`;
                logToConsole(`Thread count set to ${displayValue}`, 'info');
            });

            const memoryTestType = document.getElementById('memory-test-type');
            if (memoryTestType) {
                memoryTestType.addEventListener('change', function() {
                    logToConsole(`Memory test type changed to ${this.value}`, 'info');
                });
            }

            const memorySize = document.getElementById('memory-size');
            if (memorySize) {
                memorySize.addEventListener('input', function() {
                    logToConsole(`Memory size set to ${this.value}MB`, 'info');
                });
            }

            document.querySelectorAll('input[type="range"]').forEach(input => {
                input.addEventListener('input', () => {
                    if (input.id === 'particleCount') {
                        const value = parseInt(input.value).toLocaleString();
                        logToConsole(`Particle count set to ${value}`, 'info');
                    } else if (input.id === 'complexity') {
                        logToConsole(`Complexity set to ${input.value}/10`, 'info');
                    } else if (input.id === 'resolution') {
                        logToConsole(`Resolution scale set to ${input.value}x`, 'info');
                    } else if (input.id === 'durationSlider') {
                        logToConsole(`Test duration set to ${input.value} seconds`, 'info');
                    } else if (input.id === 'iterationCount') {
                        logToConsole(`Iteration count set to ${input.value}`, 'info');
                    }
                });
            });

            updateHistoryView();

            const userAgent = navigator.userAgent;
            logToConsole(`Browser: ${userAgent}`, 'info');

            let webglSupported = false;
            try {
                const canvas = document.createElement('canvas');
                webglSupported = !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
            } catch (e) {
                webglSupported = false;
            }

            if (!webglSupported) {
                logToConsole('WARNING: WebGL is not supported or enabled in this browser!', 'error');
                document.getElementById('gpu-mode').disabled = true;
                document.getElementById('cpu-single-mode').checked = true;
                document.getElementById('cpu-single-mode').dispatchEvent(new Event('change'));
            } else {
                logToConsole('WebGL is supported in this browser', 'info');
            }

            logToConsole('System initialized and ready', 'info');

            const memorySizeEl = document.getElementById('memory-size');
            if (memorySizeEl) {
                const memorySizeDisplay = createRangeValueDisplay(memorySizeEl, ' MB');

                memorySizeEl.addEventListener('input', function() {
                    logToConsole(`Memory size set to ${this.value}MB`, 'info');
                });
            }

            const complexityEl = document.getElementById('complexity');
            if (complexityEl) {
                createRangeValueDisplay(complexityEl);
            }

            const particleCountEl = document.getElementById('particleCount');
            if (particleCountEl) {
                const display = createRangeValueDisplay(particleCountEl);
                particleCountEl.addEventListener('input', function() {
                    display.textContent = parseInt(this.value).toLocaleString();
                    logToConsole(`Particle count set to ${display.textContent}`, 'info');
                });
                display.textContent = parseInt(particleCountEl.value).toLocaleString();
            }

            const resolutionEl = document.getElementById('resolution');
            if (resolutionEl) {
                createRangeValueDisplay(resolutionEl, 'x');
            }

            const durationSliderEl = document.getElementById('durationSlider');
            if (durationSliderEl) {
                createRangeValueDisplay(durationSliderEl, ' seconds');
            }

            const iterationCountEl = document.getElementById('iterationCount');
            if (iterationCountEl) {
                const display = createRangeValueDisplay(iterationCountEl);
                iterationCountEl.addEventListener('input', function() {
                    display.textContent = parseInt(this.value).toLocaleString();
                    logToConsole(`Iteration count set to ${display.textContent}`, 'info');
                });
                display.textContent = parseInt(iterationCountEl.value).toLocaleString();
            }

            const memoryTestTypeEl = document.getElementById('memory-test-type');
            if (memoryTestTypeEl) {
                memoryTestTypeEl.addEventListener('change', function() {
                    const testTypes = {
                        'allocation': 'Allocation test'
                    };
                    logToConsole(`Memory test type changed to ${testTypes[this.value] || this.value}`, 'info');
                });
            }
        } catch (e) {
            logToConsole(`Error during initialization: ${e.message}`, 'error');
            console.error(e);
        }
    });

    class MemoryTest extends BaseTest {
        constructor() {
            super();
            this.canvas = document.getElementById('cpuCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.memorySize = 256;
            this.testType = 'allocation';
            this.memoryArrays = [];
            this.currentArray = null;
            this.chunkSize = 1024 * 1024;
            this.particles = [];

            this.detectMemory();
            this.resize();

            window.addEventListener('resize', () => this.resize());

            logToConsole('Memory test initialized', 'info');
        }

        detectMemory() {
            let memInfo = navigator.deviceMemory ?
                `RAM: ${navigator.deviceMemory}GB` :
                'Memory info not available';

            let displayInfo = memInfo;
            if (this.testType) {
                const testTypes = {
                    'allocation': 'Тест аллокации'
                };

                displayInfo = `${memInfo} | ${testTypes[this.testType] || this.testType}`;
            }

            document.getElementById('hardware-info').textContent = displayInfo;
            logToConsole(`Detected ${memInfo}`, 'info');
        }

        resize() {
            const width = this.canvas.clientWidth;
            const height = this.canvas.clientHeight;

            if (this.canvas.width !== width || this.canvas.height !== height) {
                this.canvas.width = width;
                this.canvas.height = height;
            }
        }

        initParticles() {
            this.particles = [];
            const particleCount = 1000;

            for (let i = 0; i < particleCount; i++) {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    radius: Math.random() * 3 + 1,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * 2 - 1
                });
            }
        }

        drawParticles(time) {
            if (!this.ctx) return;

            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            const angleOffset = time * 0.001 * this.complexity;

            for (let i = 0; i < this.particles.length; i++) {
                const p = this.particles[i];

                p.x += p.vx + Math.sin(angleOffset + i * 0.1) * 0.5;
                p.y += p.vy + Math.cos(angleOffset + i * 0.1) * 0.5;

                if (p.x < 0) p.x = this.canvas.width;
                if (p.x > this.canvas.width) p.x = 0;
                if (p.y < 0) p.y = this.canvas.height;
                if (p.y > this.canvas.height) p.y = 0;

                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = p.color;
                this.ctx.fill();
            }
        }

        allocateMemory() {
            try {
                this.memoryArrays = [];

                const totalSize = this.memorySize * 1024 * 1024;
                const chunks = Math.ceil(totalSize / this.chunkSize);

                logToConsole(`Allocating ${this.memorySize}MB in ${chunks} chunks`, 'info');

                let allocatedSize = 0;

                for (let i = 0; i < chunks; i++) {
                    const arr = new Uint8Array(this.chunkSize);
                    for (let j = 0; j < arr.length; j += 1024) {
                        arr[j] = j % 256;
                    }
                    this.memoryArrays.push(arr);
                    allocatedSize += this.chunkSize;

                    if (i % 10 === 0) {
                        const progress = (allocatedSize / totalSize) * 100;
                        document.getElementById('test-progress').style.width = `${progress}%`;
                        document.getElementById('test-progress').nextElementSibling.textContent = `${Math.round(progress)}%`;
                    }
                }

                return true;
            } catch (e) {
                logToConsole(`Error allocating memory: ${e.message}`, 'error');
                return false;
            }
        }

        testBandwidth() {
            return 0;
        }

        async testLatency() {
            return 0;
        }

        async performMemoryTest() {
            let performanceMetric = 0;

            try {
                if (this.performanceReadings === 0) {
                    const startAlloc = performance.now();
                    this.allocateMemory();
                    const endAlloc = performance.now();
                    this.lastMetric = this.memorySize / ((endAlloc - startAlloc) / 1000);
                }

                performanceMetric = this.lastMetric || 0;

                const fluctuation = 0.05;
                performanceMetric = performanceMetric * (1 + (Math.random() * fluctuation * 2 - fluctuation));

            } catch (e) {
                logToConsole(`Memory test error: ${e.message}`, 'error');
            }

            return performanceMetric;
        }

        start() {
            super.start();

            document.getElementById('fps-label').textContent = 'MB/s:';

            this.memorySize = parseInt(document.getElementById('memory-size').value);
            this.testType = document.getElementById('memory-test-type').value;

            this.detectMemory();

            this.initParticles();

            if (this.testType === 'allocation') {
                document.getElementById('test-progress').style.width = '0%';
                document.getElementById('test-progress').nextElementSibling.textContent = '0%';
            }

            this.lastMetric = 0;

            this.lastFrameTime = performance.now();
            this.frameId = requestAnimationFrame(async (timestamp) => {
                await this.update(timestamp);
            });

            this.testResults = {
                mode: 'memory',
                testType: this.testType,
                memorySize: this.memorySize,
                hardware: document.getElementById('hardware-info').textContent
            };

            const testTypes = {
                'allocation': 'Тест аллокации',
                'speedtest': 'Тест скорости интернета',
                'latency': 'Тест задержки'
            };

            logToConsole(`Starting memory test (${testTypes[this.testType] || this.testType}) with ${this.memorySize}MB`, 'info');
        }

        async update(now) {
            if (!this.running) return;

            this.elapsedTime = Math.floor((now - this.startTime) / 1000);

            try {
                const performanceValue = await this.performMemoryTest();

                this.totalPerformance += performanceValue;
                this.performanceReadings++;
                this.minPerformance = Math.min(this.minPerformance, performanceValue);
                this.maxPerformance = Math.max(this.maxPerformance, performanceValue);

                const secondsElapsed = (now - this.startTime) / 1000;
                if (this.performanceHistory.length === 0 ||
                    secondsElapsed - this.performanceHistory[this.performanceHistory.length - 1].time >= 0.5) {
                    let metricLabel = 'MB/s';
                    if (this.testType === 'latency') {
                        metricLabel = 'Score';
                    }

                    this.performanceHistory.push({
                        time: secondsElapsed,
                        performance: performanceValue,
                        metric: metricLabel
                    });

                    updatePerformanceChart(this.performanceHistory);
                }

                this.drawParticles(now);

                this.updateUIStats(performanceValue);
            } catch (e) {
                logToConsole(`Memory test error: ${e.message}`, 'error');
            }

            if (this.elapsedTime >= this.testDuration) {
                this.stop();
                return;
            }

            if (this.running) {
                this.frameId = requestAnimationFrame(async (timestamp) => {
                    await this.update(timestamp);
                });
            }
        }

        stop() {
            super.stop();

            if (this.frameId) {
                cancelAnimationFrame(this.frameId);
                this.frameId = null;
            }

            document.getElementById('test-progress').style.width = '100%';
            document.getElementById('test-progress').nextElementSibling.textContent = '100%';

            this.memoryArrays = [];

            if (this.testResults) {
                this.testResults.memory = {
                    testType: this.testType,
                    memorySize: this.memorySize
                };
            }

            document.getElementById('fps-label').textContent = 'FPS:';

            logToConsole('Memory test completed', 'info');
        }
    }

    function updateBenchmarkComparison() {
        const data = getAllTestResults();
        if (!data) return;

        let bestGpuScore = 0;
        let bestCpuScore = 0;
        let bestMemoryScore = 0;

        for (const day in data) {
            data[day].forEach(test => {
                if (test.mode === 'gpu' && test.score > bestGpuScore) {
                    bestGpuScore = test.score;
                } else if ((test.mode === 'cpu-single' || test.mode === 'cpu-multi') && test.score > bestCpuScore) {
                    bestCpuScore = test.score;
                } else if (test.mode === 'memory' && test.score > bestMemoryScore) {
                    bestMemoryScore = test.score;
                }
            });
        }

        if (bestGpuScore === 0 && bestCpuScore === 0 && bestMemoryScore === 0) {
            logToConsole('No benchmark data available', 'warn');
            return;
        }

        const overallScore = Math.round((bestGpuScore + bestCpuScore + bestMemoryScore) / 3);

        const benchmarkCtx = document.getElementById('benchmarkComparisonChart').getContext('2d');

        if (window.benchmarkChart) {
            window.benchmarkChart.destroy();
        }

        const benchmarkData = [];
        const benchmarkLabels = [];
        const tableRows = document.querySelectorAll('#benchmark-table tr');

        tableRows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 5) {
                benchmarkLabels.push(cells[0].textContent);
                benchmarkData.push(parseInt(cells[4].textContent));
            }
        });

        benchmarkLabels.push('Your computer');
        benchmarkData.push(overallScore);

        window.benchmarkChart = new Chart(benchmarkCtx, {
            type: 'bar',
            data: {
                labels: benchmarkLabels,
                datasets: [{
                    label: 'Total score',
                    data: benchmarkData,
                    backgroundColor: benchmarkData.map((value, index) =>
                        index === benchmarkData.length - 1 ? 'rgba(255, 99, 132, 0.7)' : 'rgba(74, 108, 247, 0.7)'
                    ),
                    borderColor: benchmarkData.map((value, index) =>
                        index === benchmarkData.length - 1 ? '#ff6384' : '#4a6cf7'
                    ),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Total score'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Score: ${context.raw}`;
                            }
                        }
                    }
                }
            }
        });

        logToConsole(`Benchmark comparison updated. Your score: ${overallScore}`, 'info');
    }

    document.addEventListener('DOMContentLoaded', () => {
        try {


            document.getElementById('memory-test-type').addEventListener('change', function() {
                logToConsole(`Memory test type changed to ${this.value}`, 'info');
            });

            document.getElementById('memory-size').addEventListener('input', function() {
                logToConsole(`Memory size set to ${this.value}MB`, 'info');
            });

        } catch (e) {
            logToConsole(`Error during initialization: ${e.message}`, 'error');
            console.error(e);
        }
    });

    class NetworkTest extends BaseTest {
        constructor() {
            super();

            this.hasTested = false;
            this.networkInfo = 'Network connection';
            this.pingResult = 0;
            this.downloadResult = 0;
            this.uploadResult = 0;
            this.currentServer = "Determining...";
            this.testServers = [
                { name: "Cloudflare", url: "https://speed.cloudflare.com/__down?bytes=25000000", location: "Nearest" },
                { name: "Google", url: "https://www.google.com", location: "USA" },
                { name: "Microsoft", url: "https://www.microsoft.com", location: "USA" },
                { name: "Vodafone UA", url: "https://www.vodafone.ua", location: "Ukraine" },
                { name: "Kyivstar", url: "https://kyivstar.ua", location: "Ukraine" },
                { name: "Lifecell", url: "https://lifecell.ua", location: "Ukraine" },
                { name: "Rozetka", url: "https://rozetka.com.ua", location: "Ukraine" },
                { name: "Ukrtelecom", url: "https://ukrtelecom.ua", location: "Ukraine" },
                { name: "Amazon AWS", url: "https://aws.amazon.com", location: "USA" },
                { name: "Netflix", url: "https://netflix.com", location: "USA" },
                { name: "Twitch", url: "https://twitch.tv", location: "USA" }
            ];
            this.selectedServer = null;

            document.getElementById('hardware-info').textContent = this.networkInfo;

            document.getElementById('fps-label').textContent = 'Download:';
            document.getElementById('fps').textContent = '0 Mbps';
            document.getElementById('temp-label').textContent = 'Upload:';
            document.getElementById('temperature').textContent = '0 Mbps';
            document.getElementById('load-label').textContent = 'Ping:';
            document.getElementById('load').textContent = '0 ms';

            document.getElementById('network-test-container').style.display = 'block';
            document.getElementById('cpuCanvas').style.display = 'none';
            document.getElementById('glCanvas').style.display = 'none';

            this.initSpeedometer();

            this.setSpeedometerValue(0);

            logToConsole('Network speed test initialized', 'info');
        }

        initSpeedometer() {
            const scaleElement = document.getElementById('speedometer-scale');
            scaleElement.innerHTML = '';

            for (let i = 0; i <= 180; i += 10) {
                const isMajor = i % 30 === 0;
                const tick = document.createElement('div');
                tick.className = isMajor ? 'speedometer-tick major' : 'speedometer-tick';
                tick.style.transform = `rotate(${i - 90}deg)`;
                scaleElement.appendChild(tick);

                if (isMajor) {
                    const label = document.createElement('div');
                    label.className = 'speedometer-label';
                    label.style.transform = `rotate(${i - 90}deg)`;

                    const span = document.createElement('span');
                    span.style.display = 'block';
                    span.style.transform = `rotate(${90 - i}deg)`;
                    span.textContent = (i / 180 * 100).toFixed(0);

                    label.appendChild(span);
                    scaleElement.appendChild(label);
                }
            }
        }

        setTestType(type) {
            const speedometer = document.querySelector('.speedometer');
            const typeIndicator = document.querySelector('.speedometer-type');

            speedometer.className = 'speedometer ' + type;
            typeIndicator.textContent = type === 'download' ? 'Download' : 'Upload';
        }

        setServerInfo(serverName, location) {
            const serverInfo = document.getElementById('server-info');
            serverInfo.textContent = `${serverName} (${location})`;
            this.currentServer = `${serverName} (${location})`;
        }

        updateOverlay(download, upload, ping) {
            document.getElementById('fps').textContent = `${download.toFixed(2)} Mbps`;
            document.getElementById('temperature').textContent = `${upload.toFixed(2)} Mbps`;
            document.getElementById('load').textContent = `${ping} ms`;
        }

        setSpeedometerValue(value) {
            const minDegree = -90;
            const maxDegree = 90;
            const maxValue = 100;

            const cappedValue = Math.min(value, maxValue);

            const degree = minDegree + (cappedValue / maxValue) * (maxDegree - minDegree);

            const needle = document.querySelector('.speedometer-needle');
            needle.style.transform = `translate(-50%, -100%) rotate(${degree}deg)`;

            const valueElement = document.querySelector('.speedometer-value');
            valueElement.innerHTML = `${value.toFixed(1)} <span class="speedometer-unit">Mbps</span>`;
        }

        async findBestServer() {
            document.getElementById('server-info').textContent = 'Identifying the region and nearest servers...';
            logToConsole('Identifying the region and nearest servers...', 'info');

            let userRegion = null;
            try {
                const response = await fetch('https://ipapi.co/json/');
                if (response.ok) {
                    const data = await response.json();
                    userRegion = data.country_name;
                    logToConsole(`An approximate location has been determined: ${data.country_name}, ${data.city}`, 'info');

                    this.networkInfo = `${data.org || 'Internet connection'} (${data.country_name})`;
                    document.getElementById('hardware-info').textContent = this.networkInfo;
                }
            } catch (e) {
                logToConsole(`Unable to locate: ${e.message}`, 'warn');
            }

            if (userRegion) {
                this.testServers.forEach(server => {
                    if (userRegion === 'Ukraine' && server.location === 'Ukraine') {
                        server.priority = 2;
                    } else if (server.location.includes(userRegion)) {
                        server.priority = 2;
                    } else if (server.name === 'Cloudflare') {
                        server.priority = 1;
                    }
                    else {
                        server.priority = 0;
                    }
                });

                this.testServers.sort((a, b) => b.priority - a.priority);
            }

            document.getElementById('server-info').textContent = 'Search for the nearest server...';

            let bestServer = null;
            let bestPing = Number.MAX_VALUE;

            for (const server of this.testServers) {
                try {
                    const start = performance.now();
                    await fetch(server.url, {
                        method: 'HEAD',
                        cache: 'no-store',
                        mode: 'no-cors',
                        timeout: 2000
                    });
                    const ping = performance.now() - start;

                    logToConsole(`Server ${server.name}: ${Math.round(ping)} ms`, 'info');

                    server.pingValue = Math.round(ping);

                    if (ping < bestPing) {
                        bestPing = ping;
                        bestServer = server;
                    }

                    if (server.priority > 0 && ping < 100) {
                        logToConsole(`The optimal server has been found: ${server.name}`, 'info');
                        break;
                    }
                } catch (e) {
                    logToConsole(`Failed to connect to the server ${server.name}: ${e.message}`, 'warn');
                }
            }

            if (bestServer) {
                this.selectedServer = bestServer;
                this.setServerInfo(bestServer.name, bestServer.location);
                logToConsole(`The nearest server has been selected: ${bestServer.name} (${bestServer.location}), ping: ${Math.round(bestPing)} ms`, 'info');
                return bestServer;
            } else {
                this.selectedServer = this.testServers[0];
                this.setServerInfo(this.testServers[0].name, this.testServers[0].location);
                logToConsole(`Failed to determine the nearest server in use ${this.testServers[0].name}`, 'warn');
                return this.testServers[0];
            }
        }

        async runNetworkTest() {
            document.getElementById('ping-value').textContent = '-';
            document.getElementById('download-value').textContent = '-';
            document.getElementById('upload-value').textContent = '-';

            const bestServer = await this.findBestServer();

            logToConsole('Beginning internet speed test...', 'info');

            document.querySelector('.speedometer').classList.add('testing');

            document.getElementById('test-progress').style.width = `10%`;
            document.getElementById('test-progress').nextElementSibling.textContent = `10%`;

            if (bestServer && bestServer.pingValue) {
                this.pingResult = bestServer.pingValue;
                document.getElementById('ping-value').textContent = `${this.pingResult} ms`;
                document.getElementById('load').textContent = `${this.pingResult} ms`;
                logToConsole(`Ping: ${this.pingResult} мс`, 'info');
            } else {
                const testUrl = this.selectedServer.url;
                const pingStart = performance.now();

                try {
                    await fetch(testUrl, { cache: 'no-store', mode: 'no-cors' });
                    const pingTime = performance.now() - pingStart;
                    this.pingResult = Math.round(pingTime);

                    document.getElementById('ping-value').textContent = `${this.pingResult} ms`;
                    document.getElementById('load').textContent = `${this.pingResult} ms`;
                    logToConsole(`Ping: ${this.pingResult} мс`, 'info');
                } catch (e) {
                    logToConsole(`Ошибка измерения ping: ${e.message}`, 'error');
                    document.getElementById('ping-value').textContent = 'Error';
                }
            }

            document.getElementById('test-progress').style.width = `30%`;
            document.getElementById('test-progress').nextElementSibling.textContent = `30%`;

            this.setTestType('download');

            this.setSpeedometerValue(0);

            try {
                logToConsole(`Boot speed test (10 sec)...`, 'info');

                const downloadTestUrl = 'https://speed.cloudflare.com/__down?bytes=100000000';

                const controller = new AbortController();
                const signal = controller.signal;

                let startTime = performance.now();
                let bytesReceived = 0;
                let lastUpdate = startTime;
                let currentSpeed = 0;
                const testDuration = 10000;
                let lastLogTime = 0;
                let testCompletedNormally = false;

                const speedUpdateInterval = setInterval(() => {
                    const now = performance.now();
                    const elapsedMs = now - startTime;
                    const remainingSec = Math.max(0, Math.ceil((testDuration - elapsedMs) / 1000));

                    if (Math.floor(elapsedMs / 1000) > lastLogTime) {
                        lastLogTime = Math.floor(elapsedMs / 1000);
                        if (remainingSec > 0) {
                            logToConsole(`Downloading: wait ${remainingSec} sec...`, 'info');
                        }
                    }

                    const duration = (now - lastUpdate) / 1000;

                    if (duration > 0 && bytesReceived > 0) {
                        currentSpeed = (bytesReceived / 1024 / 1024 * 8) / duration;
                        this.setSpeedometerValue(currentSpeed);
                        document.getElementById('fps').textContent = `${currentSpeed.toFixed(2)} Mbps`;

                        bytesReceived = 0;
                        lastUpdate = now;
                    }

                    if (elapsedMs >= testDuration && !testCompletedNormally) {
                        logToConsole(`Download test completed by timer (${testDuration/1000} seconds)`, 'info');
                        controller.abort();
                    }
                }, 200);

                try {
                    const response = await fetch(downloadTestUrl, {
                        cache: 'no-store',
                        signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    let receivedLength = 0;

                    const chunks = [];
                    let done = false, value;

                    try {
                        while (!done) {
                            const readResult = await reader.read();
                            done = readResult.done;
                            value = readResult.value;

                            if (done) {
                                testCompletedNormally = true;
                                break;
                            }

                            chunks.push(value);
                            receivedLength += value.length;
                            bytesReceived += value.length;
                        }
                    } catch (readError) {
                        if (readError.name === 'AbortError') {
                            logToConsole('Тест загрузки был прерван по времени', 'info');
                        } else {
                            throw readError;
                        }
                    }

                    clearInterval(speedUpdateInterval);

                    const downloadTime = (performance.now() - startTime) / 1000;
                    this.downloadResult = (receivedLength / 1024 / 1024 * 8) / downloadTime;

                    document.getElementById('download-value').textContent = `${this.downloadResult.toFixed(2)} Mbps`;
                    document.getElementById('fps').textContent = `${this.downloadResult.toFixed(2)} Mbps`;

                    this.setSpeedometerValue(this.downloadResult);

                    logToConsole(`Скорость загрузки: ${this.downloadResult.toFixed(2)} Mbps`, 'info');
                } catch (fetchError) {
                    clearInterval(speedUpdateInterval);

                    if (fetchError.name === 'AbortError') {
                        const downloadTime = (performance.now() - startTime) / 1000;
                        if (bytesReceived > 0) {
                            this.downloadResult = (bytesReceived / 1024 / 1024 * 8) / downloadTime;
                            document.getElementById('download-value').textContent = `${this.downloadResult.toFixed(2)} Mbps`;
                            document.getElementById('fps').textContent = `${this.downloadResult.toFixed(2)} Mbps`;
                            this.setSpeedometerValue(this.downloadResult);
                            logToConsole(`Скорость загрузки: ${this.downloadResult.toFixed(2)} Mbps`, 'info');
                        } else {
                            this.downloadResult = 0.1;
                            document.getElementById('download-value').textContent = `<0.1 Mbps`;
                            document.getElementById('fps').textContent = `<0.1 Mbps`;
                            this.setSpeedometerValue(0.1);
                            logToConsole(`Не удалось точно измерить скорость загрузки из-за прерывания`, 'warn');
                        }
                    } else {
                        logToConsole(`Ошибка измерения скорости загрузки: ${fetchError.message}`, 'error');
                        document.getElementById('download-value').textContent = 'Error';
                    }
                }
            } catch (e) {
                logToConsole(`Общая ошибка при тестировании скорости загрузки: ${e.message}`, 'error');
                document.getElementById('download-value').textContent = 'Error';
            }

            document.getElementById('test-progress').style.width = `60%`;
            document.getElementById('test-progress').nextElementSibling.textContent = `60%`;

            this.setTestType('upload');
            this.setSpeedometerValue(0);
            await new Promise(resolve => setTimeout(resolve, 200));

            try {
                logToConsole(`Тестирование скорости выгрузки (10 сек)...`, 'info');

                const uploadSize = 50 * 1024 * 1024;
                const chunkSize = 500 * 1024;
                const totalChunks = Math.ceil(uploadSize / chunkSize);
                const singleChunk = new Uint8Array(chunkSize);

                for (let i = 0; i < chunkSize; i++) {
                    singleChunk[i] = Math.floor(Math.random() * 256);
                }

                const uploadStart = performance.now();
                let lastMeasurement = uploadStart;
                let bytesSent = 0;
                let currentUploadSpeed = 0;
                const testDuration = 10000;
                let lastLogTime = 0;

                const uploadSpeedInterval = setInterval(() => {
                    const now = performance.now();
                    const elapsedMs = now - uploadStart;
                    const remainingSec = Math.max(0, Math.ceil((testDuration - elapsedMs) / 1000));

                    if (Math.floor(elapsedMs / 1000) > lastLogTime) {
                        lastLogTime = Math.floor(elapsedMs / 1000);
                        if (remainingSec > 0) {
                            logToConsole(`Выгрузка: осталось ${remainingSec} сек...`, 'info');
                        }
                    }

                    const duration = (now - lastMeasurement) / 1000;

                    if (duration > 0 && bytesSent > 0) {
                        currentUploadSpeed = (bytesSent / 1024 / 1024 * 8) / duration;
                        this.setSpeedometerValue(currentUploadSpeed);
                        document.getElementById('temperature').textContent = `${currentUploadSpeed.toFixed(2)} Mbps`;

                        bytesSent = 0;
                        lastMeasurement = now;
                    }
                }, 200);

                let totalBytesSent = 0;
                let continueUploading = true;

                const testDurationPromise = new Promise(resolve => {
                    setTimeout(() => {
                        continueUploading = false;
                        resolve();
                    }, testDuration);
                });

                const uploadChunk = async (chunkIndex) => {
                    if (!continueUploading || chunkIndex >= totalChunks) {
                        return;
                    }

                    const chunk = (chunkIndex === totalChunks - 1 && uploadSize % chunkSize !== 0) ?
                        singleChunk.slice(0, uploadSize % chunkSize) : singleChunk;

                    try {
                        const response = await fetch('https://httpbin.org/post', {
                            method: 'POST',
                            body: chunk,
                            cache: 'no-store'
                        });

                        if (response.ok) {
                            totalBytesSent += chunk.length;
                            bytesSent += chunk.length;
                        }

                        if (continueUploading) {
                            await uploadChunk((chunkIndex + 1) % totalChunks);
                        }
                    } catch (e) {
                        logToConsole(`Ошибка отправки чанка: ${e.message}`, 'error');
                        if (continueUploading) {
                            await uploadChunk((chunkIndex + 1) % totalChunks);
                        }
                    }
                };

                await Promise.race([
                    uploadChunk(0),
                    testDurationPromise
                ]);

                clearInterval(uploadSpeedInterval);

                const uploadTime = (performance.now() - uploadStart) / 1000;
                this.uploadResult = (totalBytesSent / 1024 / 1024 * 8) / uploadTime;

                this.setSpeedometerValue(this.uploadResult);

                document.getElementById('upload-value').textContent = `${this.uploadResult.toFixed(2)} Mbps`;
                document.getElementById('temperature').textContent = `${this.uploadResult.toFixed(2)} Mbps`;
                logToConsole(`Скорость выгрузки: ${this.uploadResult.toFixed(2)} Mbps`, 'info');
            } catch (e) {
                logToConsole(`Ошибка измерения скорости выгрузки: ${e.message}`, 'error');
                document.getElementById('upload-value').textContent = 'Error';
            }

            document.querySelector('.speedometer').classList.remove('testing');

            document.getElementById('test-progress').style.width = '100%';
            document.getElementById('test-progress').nextElementSibling.textContent = '100%';

            return (this.downloadResult * 0.8 + this.uploadResult * 0.2);
        }

        async start() {
            super.start();

            document.getElementById('test-progress').style.width = '0%';
            document.getElementById('test-progress').nextElementSibling.textContent = '0%';

            if (!this.hasTested) {
                try {
                    const result = await this.runNetworkTest();
                    this.currentPerformance = result;
                    this.hasTested = true;

                    this.totalPerformance = result;
                    this.performanceReadings = 1;
                    this.minPerformance = result;
                    this.maxPerformance = result;

                    const secondsElapsed = (performance.now() - this.startTime) / 1000;
                    this.performanceHistory.push({
                        time: secondsElapsed,
                        performance: result,
                        metric: 'Mbps'
                    });

                    updatePerformanceChart(this.performanceHistory);
                    this.updateUIStats(result);

                    this.showDetailedResults();

                    this.testResults = {
                        mode: 'network',
                        ping: this.pingResult,
                        download: this.downloadResult,
                        upload: this.uploadResult,
                        score: Math.round(result * 100),
                        hardware: `${this.networkInfo} | ${this.currentServer}`
                    };

                    this.stop();
                } catch (e) {
                    logToConsole(`Ошибка в тесте скорости: ${e.message}`, 'error');
                    this.stop();
                }
            } else {
                logToConsole('Тест скорости интернета уже был выполнен', 'info');
                this.stop();
            }
        }

        stop() {
            super.stop();

            this.showDetailedResults();

            this.resetOverlay();

            logToConsole('Network speed test completed', 'info');
        }

        resetOverlay() {
            const downloadValue = this.downloadResult > 0 ? `${this.downloadResult.toFixed(2)} Mbps` : '0 Mbps';
            const uploadValue = this.uploadResult > 0 ? `${this.uploadResult.toFixed(2)} Mbps` : '0 Mbps';
            const pingValue = this.pingResult > 0 ? `${this.pingResult} ms` : '0 ms';

            document.getElementById('fps-label').textContent = 'Download:';
            document.getElementById('temp-label').textContent = 'Upload:';
            document.getElementById('load-label').textContent = 'Ping:';

            document.getElementById('fps').textContent = downloadValue;
            document.getElementById('temperature').textContent = uploadValue;
            document.getElementById('load').textContent = pingValue;
        }

        getRating(type, value) {
            switch(type) {
                case 'ping':
                    if (value < 20) return 'Great';
                    if (value < 50) return 'Good';
                    if (value < 100) return 'Ok';
                    return 'Bad';
                case 'download':
                    if (value > 50) return 'Great';
                    if (value > 25) return 'Good';
                    if (value > 10) return 'Ok';
                    return 'Bad';
                case 'upload':
                    if (value > 25) return 'Great';
                    if (value > 10) return 'Good';
                    if (value > 5) return 'Ok';
                    return 'Bad';
                default:
                    return '-';
            }
        }

        showDetailedResults() {
            const detailsContainer = document.getElementById('network-result-details');
            detailsContainer.style.display = 'block';

            document.getElementById('ping-detail').textContent = `${this.pingResult} ms`;
            document.getElementById('download-detail').textContent = `${this.downloadResult.toFixed(2)} Mbps`;
            document.getElementById('upload-detail').textContent = `${this.uploadResult.toFixed(2)} Mbps`;
            document.getElementById('server-detail').textContent = this.currentServer;

            document.getElementById('ping-rating').textContent = this.getRating('ping', this.pingResult);
            document.getElementById('download-rating').textContent = this.getRating('download', this.downloadResult);
            document.getElementById('upload-rating').textContent = this.getRating('upload', this.uploadResult);

            const ratings = document.querySelectorAll('[id$="-rating"]');

            ratings.forEach(el => {
                const text = el.textContent;

                switch(text) {
                    case 'Great':
                        el.style.color = '#28a745';
                        break;
                    case 'Good':
                        el.style.color = '#4a6cf7';
                        break;
                    case 'Ok':
                        el.style.color = '#ffc107';
                        break;
                    case 'Bad':
                        el.style.color = '#dc3545';
                        break;
                }
            });
        }
    }

    function updateBenchmarkComparison() {
    }

    function updateBenchmarkComparison() {
        const data = getAllTestResults();
        if (!data) return;

        let bestGpuScore = 0;
        let bestCpuScore = 0;
        let bestMemoryScore = 0;

        for (const day in data) {
            data[day].forEach(test => {
                if (test.mode === 'gpu' && test.score > bestGpuScore) {
                    bestGpuScore = test.score;
                } else if ((test.mode === 'cpu-single' || test.mode === 'cpu-multi') && test.score > bestCpuScore) {
                    bestCpuScore = test.score;
                } else if (test.mode === 'memory' && test.score > bestMemoryScore) {
                    bestMemoryScore = test.score;
                }
            });
        }

        if (bestGpuScore === 0 && bestCpuScore === 0 && bestMemoryScore === 0) {
            logToConsole('No benchmark data available', 'warn');
            return;
        }

        const overallScore = Math.round((bestGpuScore + bestCpuScore + bestMemoryScore) / 3);

        const benchmarkCtx = document.getElementById('benchmarkComparisonChart').getContext('2d');

        if (window.benchmarkChart) {
            window.benchmarkChart.destroy();
        }

        const benchmarkData = [];
        const benchmarkLabels = [];
        const tableRows = document.querySelectorAll('#benchmark-table tr');

        tableRows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 5) {
                benchmarkLabels.push(cells[0].textContent);
                benchmarkData.push(parseInt(cells[4].textContent));
            }
        });

        benchmarkLabels.push('Your computer');
        benchmarkData.push(overallScore);

        window.benchmarkChart = new Chart(benchmarkCtx, {
            type: 'bar',
            data: {
                labels: benchmarkLabels,
                datasets: [{
                    label: 'Total score',
                    data: benchmarkData,
                    backgroundColor: benchmarkData.map((value, index) =>
                        index === benchmarkData.length - 1 ? 'rgba(255, 99, 132, 0.7)' : 'rgba(74, 108, 247, 0.7)'
                    ),
                    borderColor: benchmarkData.map((value, index) =>
                        index === benchmarkData.length - 1 ? '#ff6384' : '#4a6cf7'
                    ),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Total Score'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Score: ${context.raw}`;
                            }
                        }
                    }
                }
            }
        });

        logToConsole(`Benchmark comparison updated. Your score: ${overallScore}`, 'info');
    }
</script>
</body>
</html>
